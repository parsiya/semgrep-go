package output

import (
	"encoding/json"
	"fmt"
)

// Extending the autogenerated output structs.

// Create an alias for the entire struct.
type Output = SemgrepOutputV1Jsonschema

// Deserialize the JSON output to a Go struct.
func Deserialize(data []byte) (Output, error) {
	var out Output
	if err := out.UnmarshalJSON(data); err != nil {
		return out, fmt.Errorf("failed to deserialize Semgrep's output: %w", err)
	}
	return out, nil
}

// Serialize the Go struct to JSON. If beautify is true, the output is indented.
func (o Output) Serialize(beautify bool) ([]byte, error) {
	if beautify {
		return json.MarshalIndent(o, "", "  ")
	}
	return json.Marshal(o)
}

// ------

// RuleID returns the rule ID of a match/hit/result as a string.
func (c CliMatch) RuleID() string {
	return string(c.CheckId)
}

// FilePath returns the file path of a match/hit/result as a string.
func (c CliMatch) FilePath() string {
	return string(c.Path)
}

// Return the message of a match/hit/result as a string.
func (c CliMatch) Message() string {
	return c.Extra.Message
}

// ------

// RuleIDHitMap returns a slice of sorted HitMapRows. The key in each row is the
// ruleID and the value is the number of hits for that rule. if sortByCount is
// true, the slice is sorted by hits in descending order (e.g., ruleIDs with
// more hits first). Otherwise, the slice is sorted by ruleID alphabetically.
func (o Output) RuleIDHitMap(sortByCount bool) []HitMapRow {
	// Create the HitMap from results.
	hm := ruleHitMap(o)
	// Get the sorted data.
	return hm.SortedData(sortByCount)
}

// FilePathHitMap returns a slice of sorted HitMapRows. The key in each row is
// the file path and the value is the number of hits for that fule. if
// sortByCount is true, the slice is sorted by hits in descending order (e.g.,
// ruleIDs with more hits first). Otherwise, the slice is sorted by file path
// alphabetically.
func (o Output) FilePathHitMap(sortByCount bool) []HitMapRow {
	// Create the HitMap from results.
	hm := fileHitMap(o)
	// Get the sorted data.
	return hm.SortedData(sortByCount)
}

// RuleIDStringTable returns a string table of sorted ruleIDs and hits.
func (o Output) RuleIDStringTable(sortByCount bool) string {
	// Create the hitmap from results.
	hm := ruleHitMap(o)
	// Get the sorted data as a table.
	return hm.ToStringTable([]string{"Rule ID, Hits"}, true)
}

// FilePathStringTable returns a string table of sorted file paths and hits.
func (o Output) FilePathStringTable(sortByCount bool) string {
	// Create the hitmap from results.
	hm := fileHitMap(o)
	// Get the sorted data as a table.
	return hm.ToStringTable([]string{"File Path, Hits"}, true)
}
