// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package v1_40_0

import "encoding/json"
import "fmt"

type CiScanCompleteResponse struct {
	// Dependencies corresponds to the JSON schema field "dependencies".
	Dependencies CiScanDependencies `json:"dependencies,omitempty" yaml:"dependencies,omitempty" mapstructure:"dependencies,omitempty"`

	// DependencyParserErrors corresponds to the JSON schema field
	// "dependency_parser_errors".
	DependencyParserErrors []DependencyParserError `json:"dependency_parser_errors,omitempty" yaml:"dependency_parser_errors,omitempty" mapstructure:"dependency_parser_errors,omitempty"`

	// ExitCode corresponds to the JSON schema field "exit_code".
	ExitCode int `json:"exit_code" yaml:"exit_code" mapstructure:"exit_code"`

	// Stats corresponds to the JSON schema field "stats".
	Stats CiScanCompleteStats `json:"stats" yaml:"stats" mapstructure:"stats"`

	// TaskId corresponds to the JSON schema field "task_id".
	TaskId *string `json:"task_id,omitempty" yaml:"task_id,omitempty" mapstructure:"task_id,omitempty"`
}

type CiScanCompleteStats struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested *string `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CliError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Findings corresponds to the JSON schema field "findings".
	Findings int `json:"findings" yaml:"findings" mapstructure:"findings"`

	// LockfileScanInfo corresponds to the JSON schema field "lockfile_scan_info".
	LockfileScanInfo CiScanCompleteStatsLockfileScanInfo `json:"lockfile_scan_info" yaml:"lockfile_scan_info" mapstructure:"lockfile_scan_info"`

	// ParseRate corresponds to the JSON schema field "parse_rate".
	ParseRate CiScanCompleteStatsParseRate `json:"parse_rate" yaml:"parse_rate" mapstructure:"parse_rate"`

	// TotalTime corresponds to the JSON schema field "total_time".
	TotalTime float64 `json:"total_time" yaml:"total_time" mapstructure:"total_time"`

	// UnsupportedExts corresponds to the JSON schema field "unsupported_exts".
	UnsupportedExts CiScanCompleteStatsUnsupportedExts `json:"unsupported_exts" yaml:"unsupported_exts" mapstructure:"unsupported_exts"`
}

type CiScanCompleteStatsLockfileScanInfo map[string]int

type CiScanCompleteStatsParseRate map[string]ParsingStats

type CiScanCompleteStatsUnsupportedExts map[string]int

type CiScanDependencies map[string][]FoundDependency

type CiScanResults struct {
	// Contributions corresponds to the JSON schema field "contributions".
	Contributions Contributions `json:"contributions,omitempty" yaml:"contributions,omitempty" mapstructure:"contributions,omitempty"`

	// Findings corresponds to the JSON schema field "findings".
	Findings []Finding `json:"findings" yaml:"findings" mapstructure:"findings"`

	// Ignores corresponds to the JSON schema field "ignores".
	Ignores []Finding `json:"ignores" yaml:"ignores" mapstructure:"ignores"`

	// RenamedPaths corresponds to the JSON schema field "renamed_paths".
	RenamedPaths []string `json:"renamed_paths" yaml:"renamed_paths" mapstructure:"renamed_paths"`

	// RuleIds corresponds to the JSON schema field "rule_ids".
	RuleIds []string `json:"rule_ids" yaml:"rule_ids" mapstructure:"rule_ids"`

	// SearchedPaths corresponds to the JSON schema field "searched_paths".
	SearchedPaths []string `json:"searched_paths" yaml:"searched_paths" mapstructure:"searched_paths"`

	// Token corresponds to the JSON schema field "token".
	Token *string `json:"token" yaml:"token" mapstructure:"token"`
}

type CliError struct {
	// Code corresponds to the JSON schema field "code".
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// Help corresponds to the JSON schema field "help".
	Help *string `json:"help,omitempty" yaml:"help,omitempty" mapstructure:"help,omitempty"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level" yaml:"level" mapstructure:"level"`

	// LongMsg corresponds to the JSON schema field "long_msg".
	LongMsg *string `json:"long_msg,omitempty" yaml:"long_msg,omitempty" mapstructure:"long_msg,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *Fpath `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// ShortMsg corresponds to the JSON schema field "short_msg".
	ShortMsg *string `json:"short_msg,omitempty" yaml:"short_msg,omitempty" mapstructure:"short_msg,omitempty"`

	// Spans corresponds to the JSON schema field "spans".
	Spans []ErrorSpan `json:"spans,omitempty" yaml:"spans,omitempty" mapstructure:"spans,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type CliMatch struct {
	// CheckId corresponds to the JSON schema field "check_id".
	CheckId RuleId `json:"check_id" yaml:"check_id" mapstructure:"check_id"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// Extra corresponds to the JSON schema field "extra".
	Extra CliMatchExtra `json:"extra" yaml:"extra" mapstructure:"extra"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

type CliMatchCallTrace interface{}

type CliMatchDataflowTrace struct {
	// IntermediateVars corresponds to the JSON schema field "intermediate_vars".
	IntermediateVars []CliMatchIntermediateVar `json:"intermediate_vars,omitempty" yaml:"intermediate_vars,omitempty" mapstructure:"intermediate_vars,omitempty"`

	// TaintSink corresponds to the JSON schema field "taint_sink".
	TaintSink CliMatchDataflowTraceTaintSink `json:"taint_sink,omitempty" yaml:"taint_sink,omitempty" mapstructure:"taint_sink,omitempty"`

	// TaintSource corresponds to the JSON schema field "taint_source".
	TaintSource CliMatchDataflowTraceTaintSource `json:"taint_source,omitempty" yaml:"taint_source,omitempty" mapstructure:"taint_source,omitempty"`
}

type CliMatchDataflowTraceTaintSink interface{}

type CliMatchDataflowTraceTaintSource interface{}

type CliMatchExtra struct {
	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *CliMatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EngineKind corresponds to the JSON schema field "engine_kind".
	EngineKind CliMatchExtraEngineKind `json:"engine_kind,omitempty" yaml:"engine_kind,omitempty" mapstructure:"engine_kind,omitempty"`

	// ExtraExtra corresponds to the JSON schema field "extra_extra".
	ExtraExtra CliMatchExtraExtraExtra `json:"extra_extra,omitempty" yaml:"extra_extra,omitempty" mapstructure:"extra_extra,omitempty"`

	// Fingerprint corresponds to the JSON schema field "fingerprint".
	Fingerprint string `json:"fingerprint" yaml:"fingerprint" mapstructure:"fingerprint"`

	// Fix corresponds to the JSON schema field "fix".
	Fix *string `json:"fix,omitempty" yaml:"fix,omitempty" mapstructure:"fix,omitempty"`

	// FixRegex corresponds to the JSON schema field "fix_regex".
	FixRegex *FixRegex `json:"fix_regex,omitempty" yaml:"fix_regex,omitempty" mapstructure:"fix_regex,omitempty"`

	// FixedLines corresponds to the JSON schema field "fixed_lines".
	FixedLines []string `json:"fixed_lines,omitempty" yaml:"fixed_lines,omitempty" mapstructure:"fixed_lines,omitempty"`

	// IsIgnored corresponds to the JSON schema field "is_ignored".
	IsIgnored *bool `json:"is_ignored,omitempty" yaml:"is_ignored,omitempty" mapstructure:"is_ignored,omitempty"`

	// Lines corresponds to the JSON schema field "lines".
	Lines string `json:"lines" yaml:"lines" mapstructure:"lines"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata CliMatchExtraMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Metavars corresponds to the JSON schema field "metavars".
	Metavars Metavars `json:"metavars,omitempty" yaml:"metavars,omitempty" mapstructure:"metavars,omitempty"`

	// ScaInfo corresponds to the JSON schema field "sca_info".
	ScaInfo *ScaInfo `json:"sca_info,omitempty" yaml:"sca_info,omitempty" mapstructure:"sca_info,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity string `json:"severity" yaml:"severity" mapstructure:"severity"`
}

type CliMatchExtraEngineKind interface{}

type CliMatchExtraExtraExtra interface{}

type CliMatchExtraMetadata interface{}

type CliMatchIntermediateVar struct {
	// Content corresponds to the JSON schema field "content".
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`
}

type CliMatchTaintSource struct {
	// Content corresponds to the JSON schema field "content".
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`
}

type CliOutputExtra struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested CliOutputExtraEngineRequested `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths CliPaths `json:"paths" yaml:"paths" mapstructure:"paths"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine,omitempty" yaml:"rules_by_engine,omitempty" mapstructure:"rules_by_engine,omitempty"`

	// Time corresponds to the JSON schema field "time".
	Time *CliTiming `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`
}

type CliOutputExtraEngineRequested interface{}

type CliPaths struct {
	// Comment corresponds to the JSON schema field "_comment".
	Comment *string `json:"_comment,omitempty" yaml:"_comment,omitempty" mapstructure:"_comment,omitempty"`

	// Scanned corresponds to the JSON schema field "scanned".
	Scanned []string `json:"scanned" yaml:"scanned" mapstructure:"scanned"`

	// Skipped corresponds to the JSON schema field "skipped".
	Skipped []CliSkippedTarget `json:"skipped,omitempty" yaml:"skipped,omitempty" mapstructure:"skipped,omitempty"`
}

type CliSkippedTarget struct {
	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Reason corresponds to the JSON schema field "reason".
	Reason CliSkippedTargetReason `json:"reason" yaml:"reason" mapstructure:"reason"`
}

type CliSkippedTargetReason interface{}

type CliTargetTimes struct {
	// MatchTimes corresponds to the JSON schema field "match_times".
	MatchTimes []float64 `json:"match_times" yaml:"match_times" mapstructure:"match_times"`

	// NumBytes corresponds to the JSON schema field "num_bytes".
	NumBytes int `json:"num_bytes" yaml:"num_bytes" mapstructure:"num_bytes"`

	// ParseTimes corresponds to the JSON schema field "parse_times".
	ParseTimes []float64 `json:"parse_times" yaml:"parse_times" mapstructure:"parse_times"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// RunTime corresponds to the JSON schema field "run_time".
	RunTime float64 `json:"run_time" yaml:"run_time" mapstructure:"run_time"`
}

type CliTiming struct {
	// MaxMemoryBytes corresponds to the JSON schema field "max_memory_bytes".
	MaxMemoryBytes *int `json:"max_memory_bytes,omitempty" yaml:"max_memory_bytes,omitempty" mapstructure:"max_memory_bytes,omitempty"`

	// ProfilingTimes corresponds to the JSON schema field "profiling_times".
	ProfilingTimes CliTimingProfilingTimes `json:"profiling_times" yaml:"profiling_times" mapstructure:"profiling_times"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []RuleIdDict `json:"rules" yaml:"rules" mapstructure:"rules"`

	// RulesParseTime corresponds to the JSON schema field "rules_parse_time".
	RulesParseTime float64 `json:"rules_parse_time" yaml:"rules_parse_time" mapstructure:"rules_parse_time"`

	// Targets corresponds to the JSON schema field "targets".
	Targets []CliTargetTimes `json:"targets" yaml:"targets" mapstructure:"targets"`

	// TotalBytes corresponds to the JSON schema field "total_bytes".
	TotalBytes int `json:"total_bytes" yaml:"total_bytes" mapstructure:"total_bytes"`
}

type CliTimingProfilingTimes map[string]float64

type Contribution struct {
	// CommitHash corresponds to the JSON schema field "commit_hash".
	CommitHash string `json:"commit_hash" yaml:"commit_hash" mapstructure:"commit_hash"`

	// CommitTimestamp corresponds to the JSON schema field "commit_timestamp".
	CommitTimestamp string `json:"commit_timestamp" yaml:"commit_timestamp" mapstructure:"commit_timestamp"`

	// Contributor corresponds to the JSON schema field "contributor".
	Contributor Contributor `json:"contributor" yaml:"contributor" mapstructure:"contributor"`
}

type Contributions []Contribution

type Contributor struct {
	// CommitAuthorEmail corresponds to the JSON schema field "commit_author_email".
	CommitAuthorEmail string `json:"commit_author_email" yaml:"commit_author_email" mapstructure:"commit_author_email"`

	// CommitAuthorName corresponds to the JSON schema field "commit_author_name".
	CommitAuthorName string `json:"commit_author_name" yaml:"commit_author_name" mapstructure:"commit_author_name"`
}

type CoreError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorType corresponds to the JSON schema field "error_type".
	ErrorType CoreErrorErrorType `json:"error_type" yaml:"error_type" mapstructure:"error_type"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity CoreErrorSeverity `json:"severity" yaml:"severity" mapstructure:"severity"`
}

type CoreErrorErrorType interface{}

type CoreErrorKind interface{}

type CoreErrorSeverity interface{}

type CoreMatch struct {
	// Extra corresponds to the JSON schema field "extra".
	Extra CoreMatchExtra `json:"extra" yaml:"extra" mapstructure:"extra"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId RuleId `json:"rule_id" yaml:"rule_id" mapstructure:"rule_id"`
}

type CoreMatchCallTrace interface{}

type CoreMatchDataflowTrace struct {
	// IntermediateVars corresponds to the JSON schema field "intermediate_vars".
	IntermediateVars []CoreMatchIntermediateVar `json:"intermediate_vars,omitempty" yaml:"intermediate_vars,omitempty" mapstructure:"intermediate_vars,omitempty"`

	// TaintSink corresponds to the JSON schema field "taint_sink".
	TaintSink CoreMatchDataflowTraceTaintSink `json:"taint_sink,omitempty" yaml:"taint_sink,omitempty" mapstructure:"taint_sink,omitempty"`

	// TaintSource corresponds to the JSON schema field "taint_source".
	TaintSource CoreMatchDataflowTraceTaintSource `json:"taint_source,omitempty" yaml:"taint_source,omitempty" mapstructure:"taint_source,omitempty"`
}

type CoreMatchDataflowTraceTaintSink interface{}

type CoreMatchDataflowTraceTaintSource interface{}

type CoreMatchExtra struct {
	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *CoreMatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EngineKind corresponds to the JSON schema field "engine_kind".
	EngineKind CoreMatchExtraEngineKind `json:"engine_kind" yaml:"engine_kind" mapstructure:"engine_kind"`

	// ExtraExtra corresponds to the JSON schema field "extra_extra".
	ExtraExtra CoreMatchExtraExtraExtra `json:"extra_extra,omitempty" yaml:"extra_extra,omitempty" mapstructure:"extra_extra,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Metavars corresponds to the JSON schema field "metavars".
	Metavars Metavars `json:"metavars" yaml:"metavars" mapstructure:"metavars"`

	// RenderedFix corresponds to the JSON schema field "rendered_fix".
	RenderedFix *string `json:"rendered_fix,omitempty" yaml:"rendered_fix,omitempty" mapstructure:"rendered_fix,omitempty"`
}

type CoreMatchExtraEngineKind interface{}

type CoreMatchExtraExtraExtra interface{}

type CoreMatchIntermediateVar struct {
	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`
}

type CoreMatchResults struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested CoreMatchResultsEngineRequested `json:"engine_requested" yaml:"engine_requested" mapstructure:"engine_requested"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CoreError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Matches corresponds to the JSON schema field "matches".
	Matches []CoreMatch `json:"matches" yaml:"matches" mapstructure:"matches"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine" yaml:"rules_by_engine" mapstructure:"rules_by_engine"`

	// Skipped corresponds to the JSON schema field "skipped".
	Skipped []SkippedTarget `json:"skipped,omitempty" yaml:"skipped,omitempty" mapstructure:"skipped,omitempty"`

	// SkippedRules corresponds to the JSON schema field "skipped_rules".
	SkippedRules []SkippedRule `json:"skipped_rules,omitempty" yaml:"skipped_rules,omitempty" mapstructure:"skipped_rules,omitempty"`

	// Stats corresponds to the JSON schema field "stats".
	Stats CoreStats `json:"stats" yaml:"stats" mapstructure:"stats"`

	// Time corresponds to the JSON schema field "time".
	Time *CoreTiming `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`
}

type CoreMatchResultsEngineRequested interface{}

type CoreSeverity interface{}

type CoreStats struct {
	// Errorfiles corresponds to the JSON schema field "errorfiles".
	Errorfiles int `json:"errorfiles" yaml:"errorfiles" mapstructure:"errorfiles"`

	// Okfiles corresponds to the JSON schema field "okfiles".
	Okfiles int `json:"okfiles" yaml:"okfiles" mapstructure:"okfiles"`
}

type CoreTiming struct {
	// MaxMemoryBytes corresponds to the JSON schema field "max_memory_bytes".
	MaxMemoryBytes int `json:"max_memory_bytes" yaml:"max_memory_bytes" mapstructure:"max_memory_bytes"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []RuleId `json:"rules" yaml:"rules" mapstructure:"rules"`

	// RulesParseTime corresponds to the JSON schema field "rules_parse_time".
	RulesParseTime *float64 `json:"rules_parse_time,omitempty" yaml:"rules_parse_time,omitempty" mapstructure:"rules_parse_time,omitempty"`

	// Targets corresponds to the JSON schema field "targets".
	Targets []TargetTime `json:"targets" yaml:"targets" mapstructure:"targets"`
}

type CveResult struct {
	// Filename corresponds to the JSON schema field "filename".
	Filename string `json:"filename" yaml:"filename" mapstructure:"filename"`

	// Funcnames corresponds to the JSON schema field "funcnames".
	Funcnames []string `json:"funcnames" yaml:"funcnames" mapstructure:"funcnames"`

	// Url corresponds to the JSON schema field "url".
	Url string `json:"url" yaml:"url" mapstructure:"url"`
}

type CveResults []CveResult

type DependencyChild struct {
	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

type DependencyMatch struct {
	// DependencyPattern corresponds to the JSON schema field "dependency_pattern".
	DependencyPattern DependencyPattern `json:"dependency_pattern" yaml:"dependency_pattern" mapstructure:"dependency_pattern"`

	// FoundDependency corresponds to the JSON schema field "found_dependency".
	FoundDependency FoundDependency `json:"found_dependency" yaml:"found_dependency" mapstructure:"found_dependency"`

	// Lockfile corresponds to the JSON schema field "lockfile".
	Lockfile string `json:"lockfile" yaml:"lockfile" mapstructure:"lockfile"`
}

type DependencyParserError struct {
	// Col corresponds to the JSON schema field "col".
	Col *int `json:"col,omitempty" yaml:"col,omitempty" mapstructure:"col,omitempty"`

	// Line corresponds to the JSON schema field "line".
	Line *int `json:"line,omitempty" yaml:"line,omitempty" mapstructure:"line,omitempty"`

	// Parser corresponds to the JSON schema field "parser".
	Parser DependencyParserErrorParser `json:"parser" yaml:"parser" mapstructure:"parser"`

	// Path corresponds to the JSON schema field "path".
	Path string `json:"path" yaml:"path" mapstructure:"path"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

type DependencyParserErrorParser interface{}

type DependencyPattern struct {
	// Ecosystem corresponds to the JSON schema field "ecosystem".
	Ecosystem DependencyPatternEcosystem `json:"ecosystem" yaml:"ecosystem" mapstructure:"ecosystem"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// SemverRange corresponds to the JSON schema field "semver_range".
	SemverRange string `json:"semver_range" yaml:"semver_range" mapstructure:"semver_range"`
}

type DependencyPatternEcosystem interface{}

type Ecosystem interface{}

type EngineKind interface{}

type ErrorSpan struct {
	// ConfigEnd corresponds to the JSON schema field "config_end".
	ConfigEnd *PositionBis `json:"config_end,omitempty" yaml:"config_end,omitempty" mapstructure:"config_end,omitempty"`

	// ConfigPath corresponds to the JSON schema field "config_path".
	ConfigPath []string `json:"config_path,omitempty" yaml:"config_path,omitempty" mapstructure:"config_path,omitempty"`

	// ConfigStart corresponds to the JSON schema field "config_start".
	ConfigStart *PositionBis `json:"config_start,omitempty" yaml:"config_start,omitempty" mapstructure:"config_start,omitempty"`

	// ContextEnd corresponds to the JSON schema field "context_end".
	ContextEnd *PositionBis `json:"context_end,omitempty" yaml:"context_end,omitempty" mapstructure:"context_end,omitempty"`

	// ContextStart corresponds to the JSON schema field "context_start".
	ContextStart *PositionBis `json:"context_start,omitempty" yaml:"context_start,omitempty" mapstructure:"context_start,omitempty"`

	// End corresponds to the JSON schema field "end".
	End PositionBis `json:"end" yaml:"end" mapstructure:"end"`

	// File corresponds to the JSON schema field "file".
	File Fpath `json:"file" yaml:"file" mapstructure:"file"`

	// SourceHash corresponds to the JSON schema field "source_hash".
	SourceHash *string `json:"source_hash,omitempty" yaml:"source_hash,omitempty" mapstructure:"source_hash,omitempty"`

	// Start corresponds to the JSON schema field "start".
	Start PositionBis `json:"start" yaml:"start" mapstructure:"start"`
}

type Finding struct {
	// CheckId corresponds to the JSON schema field "check_id".
	CheckId RuleId `json:"check_id" yaml:"check_id" mapstructure:"check_id"`

	// Column corresponds to the JSON schema field "column".
	Column int `json:"column" yaml:"column" mapstructure:"column"`

	// CommitDate corresponds to the JSON schema field "commit_date".
	CommitDate string `json:"commit_date" yaml:"commit_date" mapstructure:"commit_date"`

	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *CliMatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EndColumn corresponds to the JSON schema field "end_column".
	EndColumn int `json:"end_column" yaml:"end_column" mapstructure:"end_column"`

	// EndLine corresponds to the JSON schema field "end_line".
	EndLine int `json:"end_line" yaml:"end_line" mapstructure:"end_line"`

	// FixedLines corresponds to the JSON schema field "fixed_lines".
	FixedLines []string `json:"fixed_lines,omitempty" yaml:"fixed_lines,omitempty" mapstructure:"fixed_lines,omitempty"`

	// Hashes corresponds to the JSON schema field "hashes".
	Hashes *FindingHashes `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// IsBlocking corresponds to the JSON schema field "is_blocking".
	IsBlocking bool `json:"is_blocking" yaml:"is_blocking" mapstructure:"is_blocking"`

	// Line corresponds to the JSON schema field "line".
	Line int `json:"line" yaml:"line" mapstructure:"line"`

	// MatchBasedId corresponds to the JSON schema field "match_based_id".
	MatchBasedId *string `json:"match_based_id,omitempty" yaml:"match_based_id,omitempty" mapstructure:"match_based_id,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata FindingMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// ScaInfo corresponds to the JSON schema field "sca_info".
	ScaInfo *ScaInfo `json:"sca_info,omitempty" yaml:"sca_info,omitempty" mapstructure:"sca_info,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity interface{} `json:"severity" yaml:"severity" mapstructure:"severity"`

	// SyntacticId corresponds to the JSON schema field "syntactic_id".
	SyntacticId string `json:"syntactic_id" yaml:"syntactic_id" mapstructure:"syntactic_id"`
}

type FindingHashes struct {
	// CodeHash corresponds to the JSON schema field "code_hash".
	CodeHash string `json:"code_hash" yaml:"code_hash" mapstructure:"code_hash"`

	// EndLineHash corresponds to the JSON schema field "end_line_hash".
	EndLineHash string `json:"end_line_hash" yaml:"end_line_hash" mapstructure:"end_line_hash"`

	// PatternHash corresponds to the JSON schema field "pattern_hash".
	PatternHash string `json:"pattern_hash" yaml:"pattern_hash" mapstructure:"pattern_hash"`

	// StartLineHash corresponds to the JSON schema field "start_line_hash".
	StartLineHash string `json:"start_line_hash" yaml:"start_line_hash" mapstructure:"start_line_hash"`
}

type FindingMetadata interface{}

type FixRegex struct {
	// Count corresponds to the JSON schema field "count".
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Regex corresponds to the JSON schema field "regex".
	Regex string `json:"regex" yaml:"regex" mapstructure:"regex"`

	// Replacement corresponds to the JSON schema field "replacement".
	Replacement string `json:"replacement" yaml:"replacement" mapstructure:"replacement"`
}

type FoundDependency struct {
	// AllowedHashes corresponds to the JSON schema field "allowed_hashes".
	AllowedHashes FoundDependencyAllowedHashes `json:"allowed_hashes" yaml:"allowed_hashes" mapstructure:"allowed_hashes"`

	// Children corresponds to the JSON schema field "children".
	Children []DependencyChild `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Ecosystem corresponds to the JSON schema field "ecosystem".
	Ecosystem FoundDependencyEcosystem `json:"ecosystem" yaml:"ecosystem" mapstructure:"ecosystem"`

	// LineNumber corresponds to the JSON schema field "line_number".
	LineNumber *int `json:"line_number,omitempty" yaml:"line_number,omitempty" mapstructure:"line_number,omitempty"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// ResolvedUrl corresponds to the JSON schema field "resolved_url".
	ResolvedUrl *string `json:"resolved_url,omitempty" yaml:"resolved_url,omitempty" mapstructure:"resolved_url,omitempty"`

	// Transitivity corresponds to the JSON schema field "transitivity".
	Transitivity FoundDependencyTransitivity `json:"transitivity" yaml:"transitivity" mapstructure:"transitivity"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

type FoundDependencyAllowedHashes map[string][]string

type FoundDependencyEcosystem interface{}

type FoundDependencyTransitivity interface{}

type Fpath string

type Location struct {
	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

type MatchingExplanation struct {
	// Children corresponds to the JSON schema field "children".
	Children []*MatchingExplanation `json:"children" yaml:"children" mapstructure:"children"`

	// Loc corresponds to the JSON schema field "loc".
	Loc Location `json:"loc" yaml:"loc" mapstructure:"loc"`

	// Matches corresponds to the JSON schema field "matches".
	Matches []CoreMatch `json:"matches" yaml:"matches" mapstructure:"matches"`

	// Op corresponds to the JSON schema field "op".
	Op MatchingExplanationOp `json:"op" yaml:"op" mapstructure:"op"`
}

type MatchingExplanationOp interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyChild) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in DependencyChild: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in DependencyChild: required")
	}
	type Plain DependencyChild
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyChild(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatchTaintSource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["content"]; !ok || v == nil {
		return fmt.Errorf("field content in CliMatchTaintSource: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CliMatchTaintSource: required")
	}
	type Plain CliMatchTaintSource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatchTaintSource(plain)
	return nil
}

type RuleId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *PositionBis) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["col"]; !ok || v == nil {
		return fmt.Errorf("field col in PositionBis: required")
	}
	if v, ok := raw["line"]; !ok || v == nil {
		return fmt.Errorf("field line in PositionBis: required")
	}
	type Plain PositionBis
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = PositionBis(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatchIntermediateVar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CoreMatchIntermediateVar: required")
	}
	type Plain CoreMatchIntermediateVar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatchIntermediateVar(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["check_id"]; !ok || v == nil {
		return fmt.Errorf("field check_id in CliMatch: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in CliMatch: required")
	}
	if v, ok := raw["extra"]; !ok || v == nil {
		return fmt.Errorf("field extra in CliMatch: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in CliMatch: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in CliMatch: required")
	}
	type Plain CliMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatch(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatchExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fingerprint"]; !ok || v == nil {
		return fmt.Errorf("field fingerprint in CliMatchExtra: required")
	}
	if v, ok := raw["lines"]; !ok || v == nil {
		return fmt.Errorf("field lines in CliMatchExtra: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in CliMatchExtra: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in CliMatchExtra: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in CliMatchExtra: required")
	}
	type Plain CliMatchExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatchExtra(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ErrorSpan) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in ErrorSpan: required")
	}
	if v, ok := raw["file"]; !ok || v == nil {
		return fmt.Errorf("field file in ErrorSpan: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in ErrorSpan: required")
	}
	type Plain ErrorSpan
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ErrorSpan(plain)
	return nil
}

type Metavars map[string]MetavarValue

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetavarValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["abstract_content"]; !ok || v == nil {
		return fmt.Errorf("field abstract_content in MetavarValue: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in MetavarValue: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in MetavarValue: required")
	}
	type Plain MetavarValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetavarValue(plain)
	return nil
}

type MetavarValue struct {
	// AbstractContent corresponds to the JSON schema field "abstract_content".
	AbstractContent string `json:"abstract_content" yaml:"abstract_content" mapstructure:"abstract_content"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// PropagatedValue corresponds to the JSON schema field "propagated_value".
	PropagatedValue *SvalueValue `json:"propagated_value,omitempty" yaml:"propagated_value,omitempty" mapstructure:"propagated_value,omitempty"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatchExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["engine_kind"]; !ok || v == nil {
		return fmt.Errorf("field engine_kind in CoreMatchExtra: required")
	}
	if v, ok := raw["metavars"]; !ok || v == nil {
		return fmt.Errorf("field metavars in CoreMatchExtra: required")
	}
	type Plain CoreMatchExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatchExtra(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SvalueValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["svalue_abstract_content"]; !ok || v == nil {
		return fmt.Errorf("field svalue_abstract_content in SvalueValue: required")
	}
	type Plain SvalueValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SvalueValue(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["extra"]; !ok || v == nil {
		return fmt.Errorf("field extra in CoreMatch: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CoreMatch: required")
	}
	if v, ok := raw["rule_id"]; !ok || v == nil {
		return fmt.Errorf("field rule_id in CoreMatch: required")
	}
	type Plain CoreMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatch(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Position) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["col"]; !ok || v == nil {
		return fmt.Errorf("field col in Position: required")
	}
	if v, ok := raw["line"]; !ok || v == nil {
		return fmt.Errorf("field line in Position: required")
	}
	if v, ok := raw["offset"]; !ok || v == nil {
		return fmt.Errorf("field offset in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

type SvalueValue struct {
	// SvalueAbstractContent corresponds to the JSON schema field
	// "svalue_abstract_content".
	SvalueAbstractContent string `json:"svalue_abstract_content" yaml:"svalue_abstract_content" mapstructure:"svalue_abstract_content"`

	// SvalueEnd corresponds to the JSON schema field "svalue_end".
	SvalueEnd *Position `json:"svalue_end,omitempty" yaml:"svalue_end,omitempty" mapstructure:"svalue_end,omitempty"`

	// SvalueStart corresponds to the JSON schema field "svalue_start".
	SvalueStart *Position `json:"svalue_start,omitempty" yaml:"svalue_start,omitempty" mapstructure:"svalue_start,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatchingExplanation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["children"]; !ok || v == nil {
		return fmt.Errorf("field children in MatchingExplanation: required")
	}
	if v, ok := raw["loc"]; !ok || v == nil {
		return fmt.Errorf("field loc in MatchingExplanation: required")
	}
	if v, ok := raw["matches"]; !ok || v == nil {
		return fmt.Errorf("field matches in MatchingExplanation: required")
	}
	if v, ok := raw["op"]; !ok || v == nil {
		return fmt.Errorf("field op in MatchingExplanation: required")
	}
	type Plain MatchingExplanation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MatchingExplanation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["code"]; !ok || v == nil {
		return fmt.Errorf("field code in CliError: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in CliError: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in CliError: required")
	}
	type Plain CliError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyParserError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["parser"]; !ok || v == nil {
		return fmt.Errorf("field parser in DependencyParserError: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in DependencyParserError: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in DependencyParserError: required")
	}
	type Plain DependencyParserError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyParserError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliSkippedTarget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in CliSkippedTarget: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in CliSkippedTarget: required")
	}
	type Plain CliSkippedTarget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliSkippedTarget(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FixRegex) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["regex"]; !ok || v == nil {
		return fmt.Errorf("field regex in FixRegex: required")
	}
	if v, ok := raw["replacement"]; !ok || v == nil {
		return fmt.Errorf("field replacement in FixRegex: required")
	}
	type Plain FixRegex
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FixRegex(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliPaths) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["scanned"]; !ok || v == nil {
		return fmt.Errorf("field scanned in CliPaths: required")
	}
	type Plain CliPaths
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliPaths(plain)
	return nil
}

type RuleIdAndEngineKind []interface{}

type ParsingStats struct {
	// BytesParsed corresponds to the JSON schema field "bytes_parsed".
	BytesParsed int `json:"bytes_parsed" yaml:"bytes_parsed" mapstructure:"bytes_parsed"`

	// NumBytes corresponds to the JSON schema field "num_bytes".
	NumBytes int `json:"num_bytes" yaml:"num_bytes" mapstructure:"num_bytes"`

	// NumTargets corresponds to the JSON schema field "num_targets".
	NumTargets int `json:"num_targets" yaml:"num_targets" mapstructure:"num_targets"`

	// TargetsParsed corresponds to the JSON schema field "targets_parsed".
	TargetsParsed int `json:"targets_parsed" yaml:"targets_parsed" mapstructure:"targets_parsed"`
}

type RuleIdDict struct {
	// Id corresponds to the JSON schema field "id".
	Id RuleId `json:"id" yaml:"id" mapstructure:"id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleIdDict) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in RuleIdDict: required")
	}
	type Plain RuleIdDict
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RuleIdDict(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundDependency) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["allowed_hashes"]; !ok || v == nil {
		return fmt.Errorf("field allowed_hashes in FoundDependency: required")
	}
	if v, ok := raw["ecosystem"]; !ok || v == nil {
		return fmt.Errorf("field ecosystem in FoundDependency: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in FoundDependency: required")
	}
	if v, ok := raw["transitivity"]; !ok || v == nil {
		return fmt.Errorf("field transitivity in FoundDependency: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in FoundDependency: required")
	}
	type Plain FoundDependency
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FoundDependency(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliTargetTimes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["match_times"]; !ok || v == nil {
		return fmt.Errorf("field match_times in CliTargetTimes: required")
	}
	if v, ok := raw["num_bytes"]; !ok || v == nil {
		return fmt.Errorf("field num_bytes in CliTargetTimes: required")
	}
	if v, ok := raw["parse_times"]; !ok || v == nil {
		return fmt.Errorf("field parse_times in CliTargetTimes: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in CliTargetTimes: required")
	}
	if v, ok := raw["run_time"]; !ok || v == nil {
		return fmt.Errorf("field run_time in CliTargetTimes: required")
	}
	type Plain CliTargetTimes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliTargetTimes(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParsingStats) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bytes_parsed"]; !ok || v == nil {
		return fmt.Errorf("field bytes_parsed in ParsingStats: required")
	}
	if v, ok := raw["num_bytes"]; !ok || v == nil {
		return fmt.Errorf("field num_bytes in ParsingStats: required")
	}
	if v, ok := raw["num_targets"]; !ok || v == nil {
		return fmt.Errorf("field num_targets in ParsingStats: required")
	}
	if v, ok := raw["targets_parsed"]; !ok || v == nil {
		return fmt.Errorf("field targets_parsed in ParsingStats: required")
	}
	type Plain ParsingStats
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ParsingStats(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliTiming) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profiling_times"]; !ok || v == nil {
		return fmt.Errorf("field profiling_times in CliTiming: required")
	}
	if v, ok := raw["rules"]; !ok || v == nil {
		return fmt.Errorf("field rules in CliTiming: required")
	}
	if v, ok := raw["rules_parse_time"]; !ok || v == nil {
		return fmt.Errorf("field rules_parse_time in CliTiming: required")
	}
	if v, ok := raw["targets"]; !ok || v == nil {
		return fmt.Errorf("field targets in CliTiming: required")
	}
	if v, ok := raw["total_bytes"]; !ok || v == nil {
		return fmt.Errorf("field total_bytes in CliTiming: required")
	}
	type Plain CliTiming
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliTiming(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanResults) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["findings"]; !ok || v == nil {
		return fmt.Errorf("field findings in CiScanResults: required")
	}
	if v, ok := raw["ignores"]; !ok || v == nil {
		return fmt.Errorf("field ignores in CiScanResults: required")
	}
	if v, ok := raw["renamed_paths"]; !ok || v == nil {
		return fmt.Errorf("field renamed_paths in CiScanResults: required")
	}
	if v, ok := raw["rule_ids"]; !ok || v == nil {
		return fmt.Errorf("field rule_ids in CiScanResults: required")
	}
	if v, ok := raw["searched_paths"]; !ok || v == nil {
		return fmt.Errorf("field searched_paths in CiScanResults: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token in CiScanResults: required")
	}
	type Plain CiScanResults
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanResults(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliOutputExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["paths"]; !ok || v == nil {
		return fmt.Errorf("field paths in CliOutputExtra: required")
	}
	type Plain CliOutputExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliOutputExtra(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanCompleteStats) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in CiScanCompleteStats: required")
	}
	if v, ok := raw["findings"]; !ok || v == nil {
		return fmt.Errorf("field findings in CiScanCompleteStats: required")
	}
	if v, ok := raw["lockfile_scan_info"]; !ok || v == nil {
		return fmt.Errorf("field lockfile_scan_info in CiScanCompleteStats: required")
	}
	if v, ok := raw["parse_rate"]; !ok || v == nil {
		return fmt.Errorf("field parse_rate in CiScanCompleteStats: required")
	}
	if v, ok := raw["total_time"]; !ok || v == nil {
		return fmt.Errorf("field total_time in CiScanCompleteStats: required")
	}
	if v, ok := raw["unsupported_exts"]; !ok || v == nil {
		return fmt.Errorf("field unsupported_exts in CiScanCompleteStats: required")
	}
	type Plain CiScanCompleteStats
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanCompleteStats(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Finding) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["check_id"]; !ok || v == nil {
		return fmt.Errorf("field check_id in Finding: required")
	}
	if v, ok := raw["column"]; !ok || v == nil {
		return fmt.Errorf("field column in Finding: required")
	}
	if v, ok := raw["commit_date"]; !ok || v == nil {
		return fmt.Errorf("field commit_date in Finding: required")
	}
	if v, ok := raw["end_column"]; !ok || v == nil {
		return fmt.Errorf("field end_column in Finding: required")
	}
	if v, ok := raw["end_line"]; !ok || v == nil {
		return fmt.Errorf("field end_line in Finding: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Finding: required")
	}
	if v, ok := raw["is_blocking"]; !ok || v == nil {
		return fmt.Errorf("field is_blocking in Finding: required")
	}
	if v, ok := raw["line"]; !ok || v == nil {
		return fmt.Errorf("field line in Finding: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in Finding: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in Finding: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in Finding: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in Finding: required")
	}
	if v, ok := raw["syntactic_id"]; !ok || v == nil {
		return fmt.Errorf("field syntactic_id in Finding: required")
	}
	type Plain Finding
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Finding(plain)
	return nil
}

type PositionBis struct {
	// Col corresponds to the JSON schema field "col".
	Col int `json:"col" yaml:"col" mapstructure:"col"`

	// Line corresponds to the JSON schema field "line".
	Line int `json:"line" yaml:"line" mapstructure:"line"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["error_type"]; !ok || v == nil {
		return fmt.Errorf("field error_type in CoreError: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CoreError: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in CoreError: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in CoreError: required")
	}
	type Plain CoreError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScaInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dependency_match"]; !ok || v == nil {
		return fmt.Errorf("field dependency_match in ScaInfo: required")
	}
	if v, ok := raw["reachability_rule"]; !ok || v == nil {
		return fmt.Errorf("field reachability_rule in ScaInfo: required")
	}
	if v, ok := raw["reachable"]; !ok || v == nil {
		return fmt.Errorf("field reachable in ScaInfo: required")
	}
	if v, ok := raw["sca_finding_schema"]; !ok || v == nil {
		return fmt.Errorf("field sca_finding_schema in ScaInfo: required")
	}
	type Plain ScaInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ScaInfo(plain)
	return nil
}

type ScaInfo struct {
	// DependencyMatch corresponds to the JSON schema field "dependency_match".
	DependencyMatch DependencyMatch `json:"dependency_match" yaml:"dependency_match" mapstructure:"dependency_match"`

	// ReachabilityRule corresponds to the JSON schema field "reachability_rule".
	ReachabilityRule bool `json:"reachability_rule" yaml:"reachability_rule" mapstructure:"reachability_rule"`

	// Reachable corresponds to the JSON schema field "reachable".
	Reachable bool `json:"reachable" yaml:"reachable" mapstructure:"reachable"`

	// ScaFindingSchema corresponds to the JSON schema field "sca_finding_schema".
	ScaFindingSchema int `json:"sca_finding_schema" yaml:"sca_finding_schema" mapstructure:"sca_finding_schema"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dependency_pattern"]; !ok || v == nil {
		return fmt.Errorf("field dependency_pattern in DependencyMatch: required")
	}
	if v, ok := raw["found_dependency"]; !ok || v == nil {
		return fmt.Errorf("field found_dependency in DependencyMatch: required")
	}
	if v, ok := raw["lockfile"]; !ok || v == nil {
		return fmt.Errorf("field lockfile in DependencyMatch: required")
	}
	type Plain DependencyMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyMatch(plain)
	return nil
}

type SkippedTargetReason interface{}

type SkippedTarget struct {
	// Details corresponds to the JSON schema field "details".
	Details string `json:"details" yaml:"details" mapstructure:"details"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Reason corresponds to the JSON schema field "reason".
	Reason SkippedTargetReason `json:"reason" yaml:"reason" mapstructure:"reason"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SkippedTarget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details in SkippedTarget: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in SkippedTarget: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in SkippedTarget: required")
	}
	type Plain SkippedTarget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SkippedTarget(plain)
	return nil
}

type SkippedRule struct {
	// Details corresponds to the JSON schema field "details".
	Details string `json:"details" yaml:"details" mapstructure:"details"`

	// Position corresponds to the JSON schema field "position".
	Position Position `json:"position" yaml:"position" mapstructure:"position"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId RuleId `json:"rule_id" yaml:"rule_id" mapstructure:"rule_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SkippedRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details in SkippedRule: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in SkippedRule: required")
	}
	if v, ok := raw["rule_id"]; !ok || v == nil {
		return fmt.Errorf("field rule_id in SkippedRule: required")
	}
	type Plain SkippedRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SkippedRule(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyPattern) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ecosystem"]; !ok || v == nil {
		return fmt.Errorf("field ecosystem in DependencyPattern: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in DependencyPattern: required")
	}
	if v, ok := raw["semver_range"]; !ok || v == nil {
		return fmt.Errorf("field semver_range in DependencyPattern: required")
	}
	type Plain DependencyPattern
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyPattern(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreStats) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errorfiles"]; !ok || v == nil {
		return fmt.Errorf("field errorfiles in CoreStats: required")
	}
	if v, ok := raw["okfiles"]; !ok || v == nil {
		return fmt.Errorf("field okfiles in CoreStats: required")
	}
	type Plain CoreStats
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreStats(plain)
	return nil
}

type RuleTimes struct {
	// MatchTime corresponds to the JSON schema field "match_time".
	MatchTime float64 `json:"match_time" yaml:"match_time" mapstructure:"match_time"`

	// ParseTime corresponds to the JSON schema field "parse_time".
	ParseTime float64 `json:"parse_time" yaml:"parse_time" mapstructure:"parse_time"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId RuleId `json:"rule_id" yaml:"rule_id" mapstructure:"rule_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleTimes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["match_time"]; !ok || v == nil {
		return fmt.Errorf("field match_time in RuleTimes: required")
	}
	if v, ok := raw["parse_time"]; !ok || v == nil {
		return fmt.Errorf("field parse_time in RuleTimes: required")
	}
	if v, ok := raw["rule_id"]; !ok || v == nil {
		return fmt.Errorf("field rule_id in RuleTimes: required")
	}
	type Plain RuleTimes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = RuleTimes(plain)
	return nil
}

type TargetTime struct {
	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// RuleTimes corresponds to the JSON schema field "rule_times".
	RuleTimes []RuleTimes `json:"rule_times" yaml:"rule_times" mapstructure:"rule_times"`

	// RunTime corresponds to the JSON schema field "run_time".
	RunTime float64 `json:"run_time" yaml:"run_time" mapstructure:"run_time"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetTime) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in TargetTime: required")
	}
	if v, ok := raw["rule_times"]; !ok || v == nil {
		return fmt.Errorf("field rule_times in TargetTime: required")
	}
	if v, ok := raw["run_time"]; !ok || v == nil {
		return fmt.Errorf("field run_time in TargetTime: required")
	}
	type Plain TargetTime
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TargetTime(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FindingHashes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["code_hash"]; !ok || v == nil {
		return fmt.Errorf("field code_hash in FindingHashes: required")
	}
	if v, ok := raw["end_line_hash"]; !ok || v == nil {
		return fmt.Errorf("field end_line_hash in FindingHashes: required")
	}
	if v, ok := raw["pattern_hash"]; !ok || v == nil {
		return fmt.Errorf("field pattern_hash in FindingHashes: required")
	}
	if v, ok := raw["start_line_hash"]; !ok || v == nil {
		return fmt.Errorf("field start_line_hash in FindingHashes: required")
	}
	type Plain FindingHashes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FindingHashes(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreTiming) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["max_memory_bytes"]; !ok || v == nil {
		return fmt.Errorf("field max_memory_bytes in CoreTiming: required")
	}
	if v, ok := raw["rules"]; !ok || v == nil {
		return fmt.Errorf("field rules in CoreTiming: required")
	}
	if v, ok := raw["targets"]; !ok || v == nil {
		return fmt.Errorf("field targets in CoreTiming: required")
	}
	type Plain CoreTiming
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreTiming(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanCompleteResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exit_code"]; !ok || v == nil {
		return fmt.Errorf("field exit_code in CiScanCompleteResponse: required")
	}
	if v, ok := raw["stats"]; !ok || v == nil {
		return fmt.Errorf("field stats in CiScanCompleteResponse: required")
	}
	type Plain CiScanCompleteResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanCompleteResponse(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatchResults) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["engine_requested"]; !ok || v == nil {
		return fmt.Errorf("field engine_requested in CoreMatchResults: required")
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in CoreMatchResults: required")
	}
	if v, ok := raw["matches"]; !ok || v == nil {
		return fmt.Errorf("field matches in CoreMatchResults: required")
	}
	if v, ok := raw["rules_by_engine"]; !ok || v == nil {
		return fmt.Errorf("field rules_by_engine in CoreMatchResults: required")
	}
	if v, ok := raw["stats"]; !ok || v == nil {
		return fmt.Errorf("field stats in CoreMatchResults: required")
	}
	type Plain CoreMatchResults
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatchResults(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Contributor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commit_author_email"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_email in Contributor: required")
	}
	if v, ok := raw["commit_author_name"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_name in Contributor: required")
	}
	type Plain Contributor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Contributor(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Contribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commit_hash"]; !ok || v == nil {
		return fmt.Errorf("field commit_hash in Contribution: required")
	}
	if v, ok := raw["commit_timestamp"]; !ok || v == nil {
		return fmt.Errorf("field commit_timestamp in Contribution: required")
	}
	if v, ok := raw["contributor"]; !ok || v == nil {
		return fmt.Errorf("field contributor in Contribution: required")
	}
	type Plain Contribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Contribution(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CveResult) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["filename"]; !ok || v == nil {
		return fmt.Errorf("field filename in CveResult: required")
	}
	if v, ok := raw["funcnames"]; !ok || v == nil {
		return fmt.Errorf("field funcnames in CveResult: required")
	}
	if v, ok := raw["url"]; !ok || v == nil {
		return fmt.Errorf("field url in CveResult: required")
	}
	type Plain CveResult
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CveResult(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatchIntermediateVar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["content"]; !ok || v == nil {
		return fmt.Errorf("field content in CliMatchIntermediateVar: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CliMatchIntermediateVar: required")
	}
	type Plain CliMatchIntermediateVar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatchIntermediateVar(plain)
	return nil
}

type Position struct {
	// Col corresponds to the JSON schema field "col".
	Col int `json:"col" yaml:"col" mapstructure:"col"`

	// Line corresponds to the JSON schema field "line".
	Line int `json:"line" yaml:"line" mapstructure:"line"`

	// Offset corresponds to the JSON schema field "offset".
	Offset int `json:"offset" yaml:"offset" mapstructure:"offset"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Location) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in Location: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in Location: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in Location: required")
	}
	type Plain Location
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Location(plain)
	return nil
}

type MatchingOperation interface{}

type RawJson interface{}

type ScaParserName interface{}

type SkipReason interface{}

type Transitivity interface{}

type Version string

type SemgrepOutputV1JsonschemaEngineRequested interface{}

// Translated by atdcat from 'semgrep_output_v1.atd'.
type SemgrepOutputV1Jsonschema struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested SemgrepOutputV1JsonschemaEngineRequested `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CliError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths CliPaths `json:"paths" yaml:"paths" mapstructure:"paths"`

	// Results corresponds to the JSON schema field "results".
	Results []CliMatch `json:"results" yaml:"results" mapstructure:"results"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine,omitempty" yaml:"rules_by_engine,omitempty" mapstructure:"rules_by_engine,omitempty"`

	// Time corresponds to the JSON schema field "time".
	Time *CliTiming `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SemgrepOutputV1Jsonschema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in SemgrepOutputV1Jsonschema: required")
	}
	if v, ok := raw["paths"]; !ok || v == nil {
		return fmt.Errorf("field paths in SemgrepOutputV1Jsonschema: required")
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in SemgrepOutputV1Jsonschema: required")
	}
	type Plain SemgrepOutputV1Jsonschema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SemgrepOutputV1Jsonschema(plain)
	return nil
}
