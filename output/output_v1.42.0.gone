// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package output

import "encoding/json"
import "fmt"

type CiScanCompleteResponse struct {
	// Dependencies corresponds to the JSON schema field "dependencies".
	Dependencies CiScanDependencies `json:"dependencies,omitempty" yaml:"dependencies,omitempty" mapstructure:"dependencies,omitempty"`

	// DependencyParserErrors corresponds to the JSON schema field
	// "dependency_parser_errors".
	DependencyParserErrors []DependencyParserError `json:"dependency_parser_errors,omitempty" yaml:"dependency_parser_errors,omitempty" mapstructure:"dependency_parser_errors,omitempty"`

	// ExitCode corresponds to the JSON schema field "exit_code".
	ExitCode int `json:"exit_code" yaml:"exit_code" mapstructure:"exit_code"`

	// Stats corresponds to the JSON schema field "stats".
	Stats CiScanCompleteStats `json:"stats" yaml:"stats" mapstructure:"stats"`

	// TaskId corresponds to the JSON schema field "task_id".
	TaskId *string `json:"task_id,omitempty" yaml:"task_id,omitempty" mapstructure:"task_id,omitempty"`
}

type CiScanCompleteStats struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested *string `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CliError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Findings corresponds to the JSON schema field "findings".
	Findings int `json:"findings" yaml:"findings" mapstructure:"findings"`

	// LockfileScanInfo corresponds to the JSON schema field "lockfile_scan_info".
	LockfileScanInfo CiScanCompleteStatsLockfileScanInfo `json:"lockfile_scan_info" yaml:"lockfile_scan_info" mapstructure:"lockfile_scan_info"`

	// ParseRate corresponds to the JSON schema field "parse_rate".
	ParseRate CiScanCompleteStatsParseRate `json:"parse_rate" yaml:"parse_rate" mapstructure:"parse_rate"`

	// TotalTime corresponds to the JSON schema field "total_time".
	TotalTime float64 `json:"total_time" yaml:"total_time" mapstructure:"total_time"`

	// UnsupportedExts corresponds to the JSON schema field "unsupported_exts".
	UnsupportedExts CiScanCompleteStatsUnsupportedExts `json:"unsupported_exts" yaml:"unsupported_exts" mapstructure:"unsupported_exts"`
}

type CiScanCompleteStatsLockfileScanInfo map[string]int

type CiScanCompleteStatsParseRate map[string]ParsingStats

type CiScanCompleteStatsUnsupportedExts map[string]int

type CiScanDependencies map[string][]FoundDependency

type CiScanResults struct {
	// Contributions corresponds to the JSON schema field "contributions".
	Contributions Contributions `json:"contributions,omitempty" yaml:"contributions,omitempty" mapstructure:"contributions,omitempty"`

	// Dependencies corresponds to the JSON schema field "dependencies".
	Dependencies CiScanDependencies `json:"dependencies,omitempty" yaml:"dependencies,omitempty" mapstructure:"dependencies,omitempty"`

	// Findings corresponds to the JSON schema field "findings".
	Findings []Finding `json:"findings" yaml:"findings" mapstructure:"findings"`

	// Ignores corresponds to the JSON schema field "ignores".
	Ignores []Finding `json:"ignores" yaml:"ignores" mapstructure:"ignores"`

	// RenamedPaths corresponds to the JSON schema field "renamed_paths".
	RenamedPaths []string `json:"renamed_paths" yaml:"renamed_paths" mapstructure:"renamed_paths"`

	// RuleIds corresponds to the JSON schema field "rule_ids".
	RuleIds []RuleId `json:"rule_ids" yaml:"rule_ids" mapstructure:"rule_ids"`

	// SearchedPaths corresponds to the JSON schema field "searched_paths".
	SearchedPaths []string `json:"searched_paths" yaml:"searched_paths" mapstructure:"searched_paths"`

	// Token corresponds to the JSON schema field "token".
	Token *string `json:"token" yaml:"token" mapstructure:"token"`
}

type CliError struct {
	// Code corresponds to the JSON schema field "code".
	Code int `json:"code" yaml:"code" mapstructure:"code"`

	// Help corresponds to the JSON schema field "help".
	Help *string `json:"help,omitempty" yaml:"help,omitempty" mapstructure:"help,omitempty"`

	// Level corresponds to the JSON schema field "level".
	Level string `json:"level" yaml:"level" mapstructure:"level"`

	// LongMsg corresponds to the JSON schema field "long_msg".
	LongMsg *string `json:"long_msg,omitempty" yaml:"long_msg,omitempty" mapstructure:"long_msg,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path *Fpath `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// ShortMsg corresponds to the JSON schema field "short_msg".
	ShortMsg *string `json:"short_msg,omitempty" yaml:"short_msg,omitempty" mapstructure:"short_msg,omitempty"`

	// Spans corresponds to the JSON schema field "spans".
	Spans []ErrorSpan `json:"spans,omitempty" yaml:"spans,omitempty" mapstructure:"spans,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type string `json:"type" yaml:"type" mapstructure:"type"`
}

type CliMatch struct {
	// CheckId corresponds to the JSON schema field "check_id".
	CheckId RuleId `json:"check_id" yaml:"check_id" mapstructure:"check_id"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// Extra corresponds to the JSON schema field "extra".
	Extra CliMatchExtra `json:"extra" yaml:"extra" mapstructure:"extra"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

type CliMatchExtra struct {
	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *MatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EngineKind corresponds to the JSON schema field "engine_kind".
	EngineKind CliMatchExtraEngineKind `json:"engine_kind,omitempty" yaml:"engine_kind,omitempty" mapstructure:"engine_kind,omitempty"`

	// ExtraExtra corresponds to the JSON schema field "extra_extra".
	ExtraExtra CliMatchExtraExtraExtra `json:"extra_extra,omitempty" yaml:"extra_extra,omitempty" mapstructure:"extra_extra,omitempty"`

	// Fingerprint corresponds to the JSON schema field "fingerprint".
	Fingerprint string `json:"fingerprint" yaml:"fingerprint" mapstructure:"fingerprint"`

	// Fix corresponds to the JSON schema field "fix".
	Fix *string `json:"fix,omitempty" yaml:"fix,omitempty" mapstructure:"fix,omitempty"`

	// FixRegex corresponds to the JSON schema field "fix_regex".
	FixRegex *FixRegex `json:"fix_regex,omitempty" yaml:"fix_regex,omitempty" mapstructure:"fix_regex,omitempty"`

	// FixedLines corresponds to the JSON schema field "fixed_lines".
	FixedLines []string `json:"fixed_lines,omitempty" yaml:"fixed_lines,omitempty" mapstructure:"fixed_lines,omitempty"`

	// IsIgnored corresponds to the JSON schema field "is_ignored".
	IsIgnored *bool `json:"is_ignored,omitempty" yaml:"is_ignored,omitempty" mapstructure:"is_ignored,omitempty"`

	// Lines corresponds to the JSON schema field "lines".
	Lines string `json:"lines" yaml:"lines" mapstructure:"lines"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata CliMatchExtraMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Metavars corresponds to the JSON schema field "metavars".
	Metavars Metavars `json:"metavars,omitempty" yaml:"metavars,omitempty" mapstructure:"metavars,omitempty"`

	// ScaInfo corresponds to the JSON schema field "sca_info".
	ScaInfo *ScaInfo `json:"sca_info,omitempty" yaml:"sca_info,omitempty" mapstructure:"sca_info,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity string `json:"severity" yaml:"severity" mapstructure:"severity"`

	// ValidationState corresponds to the JSON schema field "validation_state".
	ValidationState CliMatchExtraValidationState `json:"validation_state,omitempty" yaml:"validation_state,omitempty" mapstructure:"validation_state,omitempty"`
}

type CliMatchExtraEngineKind interface{}

type CliMatchExtraExtraExtra interface{}

type CliMatchExtraMetadata interface{}

type CliMatchExtraValidationState interface{}

type CliOutputExtra struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested CliOutputExtraEngineRequested `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths ScannedAndSkipped `json:"paths" yaml:"paths" mapstructure:"paths"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine,omitempty" yaml:"rules_by_engine,omitempty" mapstructure:"rules_by_engine,omitempty"`

	// SkippedRules corresponds to the JSON schema field "skipped_rules".
	SkippedRules []SkippedRule `json:"skipped_rules,omitempty" yaml:"skipped_rules,omitempty" mapstructure:"skipped_rules,omitempty"`

	// Time corresponds to the JSON schema field "time".
	Time *Profile `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`
}

type CliOutputExtraEngineRequested interface{}

type Contribution struct {
	// CommitHash corresponds to the JSON schema field "commit_hash".
	CommitHash string `json:"commit_hash" yaml:"commit_hash" mapstructure:"commit_hash"`

	// CommitTimestamp corresponds to the JSON schema field "commit_timestamp".
	CommitTimestamp string `json:"commit_timestamp" yaml:"commit_timestamp" mapstructure:"commit_timestamp"`

	// Contributor corresponds to the JSON schema field "contributor".
	Contributor Contributor `json:"contributor" yaml:"contributor" mapstructure:"contributor"`
}

type Contributions []Contribution

type Contributor struct {
	// CommitAuthorEmail corresponds to the JSON schema field "commit_author_email".
	CommitAuthorEmail string `json:"commit_author_email" yaml:"commit_author_email" mapstructure:"commit_author_email"`

	// CommitAuthorName corresponds to the JSON schema field "commit_author_name".
	CommitAuthorName string `json:"commit_author_name" yaml:"commit_author_name" mapstructure:"commit_author_name"`
}

type CoreError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorType corresponds to the JSON schema field "error_type".
	ErrorType CoreErrorErrorType `json:"error_type" yaml:"error_type" mapstructure:"error_type"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity CoreErrorSeverity `json:"severity" yaml:"severity" mapstructure:"severity"`
}

type CoreErrorErrorType interface{}

type CoreErrorKind interface{}

type CoreErrorSeverity interface{}

type CoreMatch struct {
	// CheckId corresponds to the JSON schema field "check_id".
	CheckId RuleId `json:"check_id" yaml:"check_id" mapstructure:"check_id"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// Extra corresponds to the JSON schema field "extra".
	Extra CoreMatchExtra `json:"extra" yaml:"extra" mapstructure:"extra"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

type CoreMatchExtra struct {
	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *MatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EngineKind corresponds to the JSON schema field "engine_kind".
	EngineKind CoreMatchExtraEngineKind `json:"engine_kind" yaml:"engine_kind" mapstructure:"engine_kind"`

	// ExtraExtra corresponds to the JSON schema field "extra_extra".
	ExtraExtra CoreMatchExtraExtraExtra `json:"extra_extra,omitempty" yaml:"extra_extra,omitempty" mapstructure:"extra_extra,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Metavars corresponds to the JSON schema field "metavars".
	Metavars Metavars `json:"metavars" yaml:"metavars" mapstructure:"metavars"`

	// RenderedFix corresponds to the JSON schema field "rendered_fix".
	RenderedFix *string `json:"rendered_fix,omitempty" yaml:"rendered_fix,omitempty" mapstructure:"rendered_fix,omitempty"`

	// ValidationState corresponds to the JSON schema field "validation_state".
	ValidationState CoreMatchExtraValidationState `json:"validation_state,omitempty" yaml:"validation_state,omitempty" mapstructure:"validation_state,omitempty"`
}

type CoreMatchExtraEngineKind interface{}

type CoreMatchExtraExtraExtra interface{}

type CoreMatchExtraValidationState interface{}

type CoreOutput struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested CoreOutputEngineRequested `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CoreError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths ScannedAndSkipped `json:"paths" yaml:"paths" mapstructure:"paths"`

	// Results corresponds to the JSON schema field "results".
	Results []CoreMatch `json:"results" yaml:"results" mapstructure:"results"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine,omitempty" yaml:"rules_by_engine,omitempty" mapstructure:"rules_by_engine,omitempty"`

	// SkippedRules corresponds to the JSON schema field "skipped_rules".
	SkippedRules []SkippedRule `json:"skipped_rules,omitempty" yaml:"skipped_rules,omitempty" mapstructure:"skipped_rules,omitempty"`

	// Time corresponds to the JSON schema field "time".
	Time *Profile `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type CoreOutputEngineRequested interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatchIntermediateVar) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["content"]; !ok || v == nil {
		return fmt.Errorf("field content in MatchIntermediateVar: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in MatchIntermediateVar: required")
	}
	type Plain MatchIntermediateVar
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MatchIntermediateVar(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Contribution) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commit_hash"]; !ok || v == nil {
		return fmt.Errorf("field commit_hash in Contribution: required")
	}
	if v, ok := raw["commit_timestamp"]; !ok || v == nil {
		return fmt.Errorf("field commit_timestamp in Contribution: required")
	}
	if v, ok := raw["contributor"]; !ok || v == nil {
		return fmt.Errorf("field contributor in Contribution: required")
	}
	type Plain Contribution
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Contribution(plain)
	return nil
}

type MatchDataflowTraceTaintSink interface{}

type Location struct {
	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Location) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in Location: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in Location: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in Location: required")
	}
	type Plain Location
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Location(plain)
	return nil
}

type MatchIntermediateVar struct {
	// Content corresponds to the JSON schema field "content".
	Content string `json:"content" yaml:"content" mapstructure:"content"`

	// Location corresponds to the JSON schema field "location".
	Location Location `json:"location" yaml:"location" mapstructure:"location"`
}

type Metavars map[string]MetavarValue

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["check_id"]; !ok || v == nil {
		return fmt.Errorf("field check_id in CoreMatch: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in CoreMatch: required")
	}
	if v, ok := raw["extra"]; !ok || v == nil {
		return fmt.Errorf("field extra in CoreMatch: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in CoreMatch: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in CoreMatch: required")
	}
	type Plain CoreMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatch(plain)
	return nil
}

type MatchDataflowTraceTaintSource interface{}

type MatchDataflowTrace struct {
	// IntermediateVars corresponds to the JSON schema field "intermediate_vars".
	IntermediateVars []MatchIntermediateVar `json:"intermediate_vars,omitempty" yaml:"intermediate_vars,omitempty" mapstructure:"intermediate_vars,omitempty"`

	// TaintSink corresponds to the JSON schema field "taint_sink".
	TaintSink MatchDataflowTraceTaintSink `json:"taint_sink,omitempty" yaml:"taint_sink,omitempty" mapstructure:"taint_sink,omitempty"`

	// TaintSource corresponds to the JSON schema field "taint_source".
	TaintSource MatchDataflowTraceTaintSource `json:"taint_source,omitempty" yaml:"taint_source,omitempty" mapstructure:"taint_source,omitempty"`
}

type FindingHashes struct {
	// CodeHash corresponds to the JSON schema field "code_hash".
	CodeHash string `json:"code_hash" yaml:"code_hash" mapstructure:"code_hash"`

	// EndLineHash corresponds to the JSON schema field "end_line_hash".
	EndLineHash string `json:"end_line_hash" yaml:"end_line_hash" mapstructure:"end_line_hash"`

	// PatternHash corresponds to the JSON schema field "pattern_hash".
	PatternHash string `json:"pattern_hash" yaml:"pattern_hash" mapstructure:"pattern_hash"`

	// StartLineHash corresponds to the JSON schema field "start_line_hash".
	StartLineHash string `json:"start_line_hash" yaml:"start_line_hash" mapstructure:"start_line_hash"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FindingHashes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["code_hash"]; !ok || v == nil {
		return fmt.Errorf("field code_hash in FindingHashes: required")
	}
	if v, ok := raw["end_line_hash"]; !ok || v == nil {
		return fmt.Errorf("field end_line_hash in FindingHashes: required")
	}
	if v, ok := raw["pattern_hash"]; !ok || v == nil {
		return fmt.Errorf("field pattern_hash in FindingHashes: required")
	}
	if v, ok := raw["start_line_hash"]; !ok || v == nil {
		return fmt.Errorf("field start_line_hash in FindingHashes: required")
	}
	type Plain FindingHashes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FindingHashes(plain)
	return nil
}

type FindingMetadata interface{}

type DependencyPatternEcosystem interface{}

type DependencyPattern struct {
	// Ecosystem corresponds to the JSON schema field "ecosystem".
	Ecosystem DependencyPatternEcosystem `json:"ecosystem" yaml:"ecosystem" mapstructure:"ecosystem"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// SemverRange corresponds to the JSON schema field "semver_range".
	SemverRange string `json:"semver_range" yaml:"semver_range" mapstructure:"semver_range"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyPattern) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["ecosystem"]; !ok || v == nil {
		return fmt.Errorf("field ecosystem in DependencyPattern: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in DependencyPattern: required")
	}
	if v, ok := raw["semver_range"]; !ok || v == nil {
		return fmt.Errorf("field semver_range in DependencyPattern: required")
	}
	type Plain DependencyPattern
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyPattern(plain)
	return nil
}

type DependencyMatch struct {
	// DependencyPattern corresponds to the JSON schema field "dependency_pattern".
	DependencyPattern DependencyPattern `json:"dependency_pattern" yaml:"dependency_pattern" mapstructure:"dependency_pattern"`

	// FoundDependency corresponds to the JSON schema field "found_dependency".
	FoundDependency FoundDependency `json:"found_dependency" yaml:"found_dependency" mapstructure:"found_dependency"`

	// Lockfile corresponds to the JSON schema field "lockfile".
	Lockfile string `json:"lockfile" yaml:"lockfile" mapstructure:"lockfile"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dependency_pattern"]; !ok || v == nil {
		return fmt.Errorf("field dependency_pattern in DependencyMatch: required")
	}
	if v, ok := raw["found_dependency"]; !ok || v == nil {
		return fmt.Errorf("field found_dependency in DependencyMatch: required")
	}
	if v, ok := raw["lockfile"]; !ok || v == nil {
		return fmt.Errorf("field lockfile in DependencyMatch: required")
	}
	type Plain DependencyMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyMatch(plain)
	return nil
}

type ScaInfo struct {
	// DependencyMatch corresponds to the JSON schema field "dependency_match".
	DependencyMatch DependencyMatch `json:"dependency_match" yaml:"dependency_match" mapstructure:"dependency_match"`

	// ReachabilityRule corresponds to the JSON schema field "reachability_rule".
	ReachabilityRule bool `json:"reachability_rule" yaml:"reachability_rule" mapstructure:"reachability_rule"`

	// Reachable corresponds to the JSON schema field "reachable".
	Reachable bool `json:"reachable" yaml:"reachable" mapstructure:"reachable"`

	// ScaFindingSchema corresponds to the JSON schema field "sca_finding_schema".
	ScaFindingSchema int `json:"sca_finding_schema" yaml:"sca_finding_schema" mapstructure:"sca_finding_schema"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScaInfo) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["dependency_match"]; !ok || v == nil {
		return fmt.Errorf("field dependency_match in ScaInfo: required")
	}
	if v, ok := raw["reachability_rule"]; !ok || v == nil {
		return fmt.Errorf("field reachability_rule in ScaInfo: required")
	}
	if v, ok := raw["reachable"]; !ok || v == nil {
		return fmt.Errorf("field reachable in ScaInfo: required")
	}
	if v, ok := raw["sca_finding_schema"]; !ok || v == nil {
		return fmt.Errorf("field sca_finding_schema in ScaInfo: required")
	}
	type Plain ScaInfo
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ScaInfo(plain)
	return nil
}

type FindingValidationState interface{}

type Finding struct {
	// CheckId corresponds to the JSON schema field "check_id".
	CheckId RuleId `json:"check_id" yaml:"check_id" mapstructure:"check_id"`

	// Column corresponds to the JSON schema field "column".
	Column int `json:"column" yaml:"column" mapstructure:"column"`

	// CommitDate corresponds to the JSON schema field "commit_date".
	CommitDate string `json:"commit_date" yaml:"commit_date" mapstructure:"commit_date"`

	// DataflowTrace corresponds to the JSON schema field "dataflow_trace".
	DataflowTrace *MatchDataflowTrace `json:"dataflow_trace,omitempty" yaml:"dataflow_trace,omitempty" mapstructure:"dataflow_trace,omitempty"`

	// EndColumn corresponds to the JSON schema field "end_column".
	EndColumn int `json:"end_column" yaml:"end_column" mapstructure:"end_column"`

	// EndLine corresponds to the JSON schema field "end_line".
	EndLine int `json:"end_line" yaml:"end_line" mapstructure:"end_line"`

	// FixedLines corresponds to the JSON schema field "fixed_lines".
	FixedLines []string `json:"fixed_lines,omitempty" yaml:"fixed_lines,omitempty" mapstructure:"fixed_lines,omitempty"`

	// Hashes corresponds to the JSON schema field "hashes".
	Hashes *FindingHashes `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// Index corresponds to the JSON schema field "index".
	Index int `json:"index" yaml:"index" mapstructure:"index"`

	// IsBlocking corresponds to the JSON schema field "is_blocking".
	IsBlocking bool `json:"is_blocking" yaml:"is_blocking" mapstructure:"is_blocking"`

	// Line corresponds to the JSON schema field "line".
	Line int `json:"line" yaml:"line" mapstructure:"line"`

	// MatchBasedId corresponds to the JSON schema field "match_based_id".
	MatchBasedId *string `json:"match_based_id,omitempty" yaml:"match_based_id,omitempty" mapstructure:"match_based_id,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message string `json:"message" yaml:"message" mapstructure:"message"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata FindingMetadata `json:"metadata" yaml:"metadata" mapstructure:"metadata"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// ScaInfo corresponds to the JSON schema field "sca_info".
	ScaInfo *ScaInfo `json:"sca_info,omitempty" yaml:"sca_info,omitempty" mapstructure:"sca_info,omitempty"`

	// Severity corresponds to the JSON schema field "severity".
	Severity interface{} `json:"severity" yaml:"severity" mapstructure:"severity"`

	// SyntacticId corresponds to the JSON schema field "syntactic_id".
	SyntacticId string `json:"syntactic_id" yaml:"syntactic_id" mapstructure:"syntactic_id"`

	// ValidationState corresponds to the JSON schema field "validation_state".
	ValidationState FindingValidationState `json:"validation_state,omitempty" yaml:"validation_state,omitempty" mapstructure:"validation_state,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Finding) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["check_id"]; !ok || v == nil {
		return fmt.Errorf("field check_id in Finding: required")
	}
	if v, ok := raw["column"]; !ok || v == nil {
		return fmt.Errorf("field column in Finding: required")
	}
	if v, ok := raw["commit_date"]; !ok || v == nil {
		return fmt.Errorf("field commit_date in Finding: required")
	}
	if v, ok := raw["end_column"]; !ok || v == nil {
		return fmt.Errorf("field end_column in Finding: required")
	}
	if v, ok := raw["end_line"]; !ok || v == nil {
		return fmt.Errorf("field end_line in Finding: required")
	}
	if v, ok := raw["index"]; !ok || v == nil {
		return fmt.Errorf("field index in Finding: required")
	}
	if v, ok := raw["is_blocking"]; !ok || v == nil {
		return fmt.Errorf("field is_blocking in Finding: required")
	}
	if v, ok := raw["line"]; !ok || v == nil {
		return fmt.Errorf("field line in Finding: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in Finding: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in Finding: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in Finding: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in Finding: required")
	}
	if v, ok := raw["syntactic_id"]; !ok || v == nil {
		return fmt.Errorf("field syntactic_id in Finding: required")
	}
	type Plain Finding
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Finding(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyParserError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["parser"]; !ok || v == nil {
		return fmt.Errorf("field parser in DependencyParserError: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in DependencyParserError: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in DependencyParserError: required")
	}
	type Plain DependencyParserError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyParserError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanResults) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["findings"]; !ok || v == nil {
		return fmt.Errorf("field findings in CiScanResults: required")
	}
	if v, ok := raw["ignores"]; !ok || v == nil {
		return fmt.Errorf("field ignores in CiScanResults: required")
	}
	if v, ok := raw["renamed_paths"]; !ok || v == nil {
		return fmt.Errorf("field renamed_paths in CiScanResults: required")
	}
	if v, ok := raw["rule_ids"]; !ok || v == nil {
		return fmt.Errorf("field rule_ids in CiScanResults: required")
	}
	if v, ok := raw["searched_paths"]; !ok || v == nil {
		return fmt.Errorf("field searched_paths in CiScanResults: required")
	}
	if v, ok := raw["token"]; !ok || v == nil {
		return fmt.Errorf("field token in CiScanResults: required")
	}
	type Plain CiScanResults
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanResults(plain)
	return nil
}

type DependencyParserError struct {
	// Col corresponds to the JSON schema field "col".
	Col *int `json:"col,omitempty" yaml:"col,omitempty" mapstructure:"col,omitempty"`

	// Line corresponds to the JSON schema field "line".
	Line *int `json:"line,omitempty" yaml:"line,omitempty" mapstructure:"line,omitempty"`

	// Parser corresponds to the JSON schema field "parser".
	Parser DependencyParserErrorParser `json:"parser" yaml:"parser" mapstructure:"parser"`

	// Path corresponds to the JSON schema field "path".
	Path string `json:"path" yaml:"path" mapstructure:"path"`

	// Reason corresponds to the JSON schema field "reason".
	Reason string `json:"reason" yaml:"reason" mapstructure:"reason"`

	// Text corresponds to the JSON schema field "text".
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

type DependencyParserErrorParser interface{}

type FixRegex struct {
	// Count corresponds to the JSON schema field "count".
	Count *int `json:"count,omitempty" yaml:"count,omitempty" mapstructure:"count,omitempty"`

	// Regex corresponds to the JSON schema field "regex".
	Regex string `json:"regex" yaml:"regex" mapstructure:"regex"`

	// Replacement corresponds to the JSON schema field "replacement".
	Replacement string `json:"replacement" yaml:"replacement" mapstructure:"replacement"`
}

type MatchingExplanation struct {
	// Children corresponds to the JSON schema field "children".
	Children []*MatchingExplanation `json:"children" yaml:"children" mapstructure:"children"`

	// Loc corresponds to the JSON schema field "loc".
	Loc Location `json:"loc" yaml:"loc" mapstructure:"loc"`

	// Matches corresponds to the JSON schema field "matches".
	Matches []CoreMatch `json:"matches" yaml:"matches" mapstructure:"matches"`

	// Op corresponds to the JSON schema field "op".
	Op MatchingExplanationOp `json:"op" yaml:"op" mapstructure:"op"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FoundDependency) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["allowed_hashes"]; !ok || v == nil {
		return fmt.Errorf("field allowed_hashes in FoundDependency: required")
	}
	if v, ok := raw["ecosystem"]; !ok || v == nil {
		return fmt.Errorf("field ecosystem in FoundDependency: required")
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in FoundDependency: required")
	}
	if v, ok := raw["transitivity"]; !ok || v == nil {
		return fmt.Errorf("field transitivity in FoundDependency: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in FoundDependency: required")
	}
	type Plain FoundDependency
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FoundDependency(plain)
	return nil
}

type SvalueValue struct {
	// SvalueAbstractContent corresponds to the JSON schema field
	// "svalue_abstract_content".
	SvalueAbstractContent string `json:"svalue_abstract_content" yaml:"svalue_abstract_content" mapstructure:"svalue_abstract_content"`

	// SvalueEnd corresponds to the JSON schema field "svalue_end".
	SvalueEnd *Position `json:"svalue_end,omitempty" yaml:"svalue_end,omitempty" mapstructure:"svalue_end,omitempty"`

	// SvalueStart corresponds to the JSON schema field "svalue_start".
	SvalueStart *Position `json:"svalue_start,omitempty" yaml:"svalue_start,omitempty" mapstructure:"svalue_start,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SvalueValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["svalue_abstract_content"]; !ok || v == nil {
		return fmt.Errorf("field svalue_abstract_content in SvalueValue: required")
	}
	type Plain SvalueValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SvalueValue(plain)
	return nil
}

type MetavarValue struct {
	// AbstractContent corresponds to the JSON schema field "abstract_content".
	AbstractContent string `json:"abstract_content" yaml:"abstract_content" mapstructure:"abstract_content"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// PropagatedValue corresponds to the JSON schema field "propagated_value".
	PropagatedValue *SvalueValue `json:"propagated_value,omitempty" yaml:"propagated_value,omitempty" mapstructure:"propagated_value,omitempty"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MetavarValue) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["abstract_content"]; !ok || v == nil {
		return fmt.Errorf("field abstract_content in MetavarValue: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in MetavarValue: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in MetavarValue: required")
	}
	type Plain MetavarValue
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MetavarValue(plain)
	return nil
}

type MatchingExplanationOp interface{}

type FoundDependency struct {
	// AllowedHashes corresponds to the JSON schema field "allowed_hashes".
	AllowedHashes FoundDependencyAllowedHashes `json:"allowed_hashes" yaml:"allowed_hashes" mapstructure:"allowed_hashes"`

	// Children corresponds to the JSON schema field "children".
	Children []DependencyChild `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Ecosystem corresponds to the JSON schema field "ecosystem".
	Ecosystem FoundDependencyEcosystem `json:"ecosystem" yaml:"ecosystem" mapstructure:"ecosystem"`

	// LineNumber corresponds to the JSON schema field "line_number".
	LineNumber *int `json:"line_number,omitempty" yaml:"line_number,omitempty" mapstructure:"line_number,omitempty"`

	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// ResolvedUrl corresponds to the JSON schema field "resolved_url".
	ResolvedUrl *string `json:"resolved_url,omitempty" yaml:"resolved_url,omitempty" mapstructure:"resolved_url,omitempty"`

	// Transitivity corresponds to the JSON schema field "transitivity".
	Transitivity FoundDependencyTransitivity `json:"transitivity" yaml:"transitivity" mapstructure:"transitivity"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

type FoundDependencyTransitivity interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatchExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fingerprint"]; !ok || v == nil {
		return fmt.Errorf("field fingerprint in CliMatchExtra: required")
	}
	if v, ok := raw["lines"]; !ok || v == nil {
		return fmt.Errorf("field lines in CliMatchExtra: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in CliMatchExtra: required")
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		return fmt.Errorf("field metadata in CliMatchExtra: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in CliMatchExtra: required")
	}
	type Plain CliMatchExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatchExtra(plain)
	return nil
}

type FoundDependencyEcosystem interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliMatch) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["check_id"]; !ok || v == nil {
		return fmt.Errorf("field check_id in CliMatch: required")
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in CliMatch: required")
	}
	if v, ok := raw["extra"]; !ok || v == nil {
		return fmt.Errorf("field extra in CliMatch: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in CliMatch: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in CliMatch: required")
	}
	type Plain CliMatch
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliMatch(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DependencyChild) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["package"]; !ok || v == nil {
		return fmt.Errorf("field package in DependencyChild: required")
	}
	if v, ok := raw["version"]; !ok || v == nil {
		return fmt.Errorf("field version in DependencyChild: required")
	}
	type Plain DependencyChild
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = DependencyChild(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanCompleteStats) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in CiScanCompleteStats: required")
	}
	if v, ok := raw["findings"]; !ok || v == nil {
		return fmt.Errorf("field findings in CiScanCompleteStats: required")
	}
	if v, ok := raw["lockfile_scan_info"]; !ok || v == nil {
		return fmt.Errorf("field lockfile_scan_info in CiScanCompleteStats: required")
	}
	if v, ok := raw["parse_rate"]; !ok || v == nil {
		return fmt.Errorf("field parse_rate in CiScanCompleteStats: required")
	}
	if v, ok := raw["total_time"]; !ok || v == nil {
		return fmt.Errorf("field total_time in CiScanCompleteStats: required")
	}
	if v, ok := raw["unsupported_exts"]; !ok || v == nil {
		return fmt.Errorf("field unsupported_exts in CiScanCompleteStats: required")
	}
	type Plain CiScanCompleteStats
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanCompleteStats(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["code"]; !ok || v == nil {
		return fmt.Errorf("field code in CliError: required")
	}
	if v, ok := raw["level"]; !ok || v == nil {
		return fmt.Errorf("field level in CliError: required")
	}
	if v, ok := raw["type"]; !ok || v == nil {
		return fmt.Errorf("field type in CliError: required")
	}
	type Plain CliError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Contributor) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["commit_author_email"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_email in Contributor: required")
	}
	if v, ok := raw["commit_author_name"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_name in Contributor: required")
	}
	type Plain Contributor
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Contributor(plain)
	return nil
}

type Position struct {
	// Col corresponds to the JSON schema field "col".
	Col int `json:"col" yaml:"col" mapstructure:"col"`

	// Line corresponds to the JSON schema field "line".
	Line int `json:"line" yaml:"line" mapstructure:"line"`

	// Offset corresponds to the JSON schema field "offset".
	Offset *int `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreMatchExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["engine_kind"]; !ok || v == nil {
		return fmt.Errorf("field engine_kind in CoreMatchExtra: required")
	}
	if v, ok := raw["metavars"]; !ok || v == nil {
		return fmt.Errorf("field metavars in CoreMatchExtra: required")
	}
	type Plain CoreMatchExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreMatchExtra(plain)
	return nil
}

type Fpath string

type FoundDependencyAllowedHashes map[string][]string

// UnmarshalJSON implements json.Unmarshaler.
func (j *Position) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["col"]; !ok || v == nil {
		return fmt.Errorf("field col in Position: required")
	}
	if v, ok := raw["line"]; !ok || v == nil {
		return fmt.Errorf("field line in Position: required")
	}
	type Plain Position
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Position(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FixRegex) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["regex"]; !ok || v == nil {
		return fmt.Errorf("field regex in FixRegex: required")
	}
	if v, ok := raw["replacement"]; !ok || v == nil {
		return fmt.Errorf("field replacement in FixRegex: required")
	}
	type Plain FixRegex
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = FixRegex(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MatchingExplanation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["children"]; !ok || v == nil {
		return fmt.Errorf("field children in MatchingExplanation: required")
	}
	if v, ok := raw["loc"]; !ok || v == nil {
		return fmt.Errorf("field loc in MatchingExplanation: required")
	}
	if v, ok := raw["matches"]; !ok || v == nil {
		return fmt.Errorf("field matches in MatchingExplanation: required")
	}
	if v, ok := raw["op"]; !ok || v == nil {
		return fmt.Errorf("field op in MatchingExplanation: required")
	}
	type Plain MatchingExplanation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = MatchingExplanation(plain)
	return nil
}

type SkippedTargetReason interface{}

type SkippedTarget struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// Reason corresponds to the JSON schema field "reason".
	Reason SkippedTargetReason `json:"reason" yaml:"reason" mapstructure:"reason"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId *RuleId `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SkippedTarget) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in SkippedTarget: required")
	}
	if v, ok := raw["reason"]; !ok || v == nil {
		return fmt.Errorf("field reason in SkippedTarget: required")
	}
	type Plain SkippedTarget
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SkippedTarget(plain)
	return nil
}

type ScannedAndSkipped struct {
	// Scanned corresponds to the JSON schema field "scanned".
	Scanned []Fpath `json:"scanned" yaml:"scanned" mapstructure:"scanned"`

	// Skipped corresponds to the JSON schema field "skipped".
	Skipped []SkippedTarget `json:"skipped,omitempty" yaml:"skipped,omitempty" mapstructure:"skipped,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ScannedAndSkipped) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["scanned"]; !ok || v == nil {
		return fmt.Errorf("field scanned in ScannedAndSkipped: required")
	}
	type Plain ScannedAndSkipped
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ScannedAndSkipped(plain)
	return nil
}

type RuleIdAndEngineKind []interface{}

type SkippedRule struct {
	// Details corresponds to the JSON schema field "details".
	Details string `json:"details" yaml:"details" mapstructure:"details"`

	// Position corresponds to the JSON schema field "position".
	Position Position `json:"position" yaml:"position" mapstructure:"position"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId RuleId `json:"rule_id" yaml:"rule_id" mapstructure:"rule_id"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SkippedRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["details"]; !ok || v == nil {
		return fmt.Errorf("field details in SkippedRule: required")
	}
	if v, ok := raw["position"]; !ok || v == nil {
		return fmt.Errorf("field position in SkippedRule: required")
	}
	if v, ok := raw["rule_id"]; !ok || v == nil {
		return fmt.Errorf("field rule_id in SkippedRule: required")
	}
	type Plain SkippedRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SkippedRule(plain)
	return nil
}

type ProfileProfilingTimes map[string]float64

type TargetTimes struct {
	// MatchTimes corresponds to the JSON schema field "match_times".
	MatchTimes []float64 `json:"match_times" yaml:"match_times" mapstructure:"match_times"`

	// NumBytes corresponds to the JSON schema field "num_bytes".
	NumBytes int `json:"num_bytes" yaml:"num_bytes" mapstructure:"num_bytes"`

	// ParseTimes corresponds to the JSON schema field "parse_times".
	ParseTimes []float64 `json:"parse_times" yaml:"parse_times" mapstructure:"parse_times"`

	// Path corresponds to the JSON schema field "path".
	Path Fpath `json:"path" yaml:"path" mapstructure:"path"`

	// RunTime corresponds to the JSON schema field "run_time".
	RunTime float64 `json:"run_time" yaml:"run_time" mapstructure:"run_time"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TargetTimes) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["match_times"]; !ok || v == nil {
		return fmt.Errorf("field match_times in TargetTimes: required")
	}
	if v, ok := raw["num_bytes"]; !ok || v == nil {
		return fmt.Errorf("field num_bytes in TargetTimes: required")
	}
	if v, ok := raw["parse_times"]; !ok || v == nil {
		return fmt.Errorf("field parse_times in TargetTimes: required")
	}
	if v, ok := raw["path"]; !ok || v == nil {
		return fmt.Errorf("field path in TargetTimes: required")
	}
	if v, ok := raw["run_time"]; !ok || v == nil {
		return fmt.Errorf("field run_time in TargetTimes: required")
	}
	type Plain TargetTimes
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TargetTimes(plain)
	return nil
}

type Profile struct {
	// MaxMemoryBytes corresponds to the JSON schema field "max_memory_bytes".
	MaxMemoryBytes *int `json:"max_memory_bytes,omitempty" yaml:"max_memory_bytes,omitempty" mapstructure:"max_memory_bytes,omitempty"`

	// ProfilingTimes corresponds to the JSON schema field "profiling_times".
	ProfilingTimes ProfileProfilingTimes `json:"profiling_times" yaml:"profiling_times" mapstructure:"profiling_times"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []RuleId `json:"rules" yaml:"rules" mapstructure:"rules"`

	// RulesParseTime corresponds to the JSON schema field "rules_parse_time".
	RulesParseTime float64 `json:"rules_parse_time" yaml:"rules_parse_time" mapstructure:"rules_parse_time"`

	// Targets corresponds to the JSON schema field "targets".
	Targets []TargetTimes `json:"targets" yaml:"targets" mapstructure:"targets"`

	// TotalBytes corresponds to the JSON schema field "total_bytes".
	TotalBytes int `json:"total_bytes" yaml:"total_bytes" mapstructure:"total_bytes"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Profile) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["profiling_times"]; !ok || v == nil {
		return fmt.Errorf("field profiling_times in Profile: required")
	}
	if v, ok := raw["rules"]; !ok || v == nil {
		return fmt.Errorf("field rules in Profile: required")
	}
	if v, ok := raw["rules_parse_time"]; !ok || v == nil {
		return fmt.Errorf("field rules_parse_time in Profile: required")
	}
	if v, ok := raw["targets"]; !ok || v == nil {
		return fmt.Errorf("field targets in Profile: required")
	}
	if v, ok := raw["total_bytes"]; !ok || v == nil {
		return fmt.Errorf("field total_bytes in Profile: required")
	}
	type Plain Profile
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Profile(plain)
	return nil
}

type DependencyChild struct {
	// Package corresponds to the JSON schema field "package".
	Package string `json:"package" yaml:"package" mapstructure:"package"`

	// Version corresponds to the JSON schema field "version".
	Version string `json:"version" yaml:"version" mapstructure:"version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CliOutputExtra) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["paths"]; !ok || v == nil {
		return fmt.Errorf("field paths in CliOutputExtra: required")
	}
	type Plain CliOutputExtra
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CliOutputExtra(plain)
	return nil
}

type ErrorSpan struct {
	// ConfigEnd corresponds to the JSON schema field "config_end".
	ConfigEnd *Position `json:"config_end,omitempty" yaml:"config_end,omitempty" mapstructure:"config_end,omitempty"`

	// ConfigPath corresponds to the JSON schema field "config_path".
	ConfigPath []string `json:"config_path,omitempty" yaml:"config_path,omitempty" mapstructure:"config_path,omitempty"`

	// ConfigStart corresponds to the JSON schema field "config_start".
	ConfigStart *Position `json:"config_start,omitempty" yaml:"config_start,omitempty" mapstructure:"config_start,omitempty"`

	// ContextEnd corresponds to the JSON schema field "context_end".
	ContextEnd *Position `json:"context_end,omitempty" yaml:"context_end,omitempty" mapstructure:"context_end,omitempty"`

	// ContextStart corresponds to the JSON schema field "context_start".
	ContextStart *Position `json:"context_start,omitempty" yaml:"context_start,omitempty" mapstructure:"context_start,omitempty"`

	// End corresponds to the JSON schema field "end".
	End Position `json:"end" yaml:"end" mapstructure:"end"`

	// File corresponds to the JSON schema field "file".
	File Fpath `json:"file" yaml:"file" mapstructure:"file"`

	// SourceHash corresponds to the JSON schema field "source_hash".
	SourceHash *string `json:"source_hash,omitempty" yaml:"source_hash,omitempty" mapstructure:"source_hash,omitempty"`

	// Start corresponds to the JSON schema field "start".
	Start Position `json:"start" yaml:"start" mapstructure:"start"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ParsingStats) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["bytes_parsed"]; !ok || v == nil {
		return fmt.Errorf("field bytes_parsed in ParsingStats: required")
	}
	if v, ok := raw["num_bytes"]; !ok || v == nil {
		return fmt.Errorf("field num_bytes in ParsingStats: required")
	}
	if v, ok := raw["num_targets"]; !ok || v == nil {
		return fmt.Errorf("field num_targets in ParsingStats: required")
	}
	if v, ok := raw["targets_parsed"]; !ok || v == nil {
		return fmt.Errorf("field targets_parsed in ParsingStats: required")
	}
	type Plain ParsingStats
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ParsingStats(plain)
	return nil
}

type ParsingStats struct {
	// BytesParsed corresponds to the JSON schema field "bytes_parsed".
	BytesParsed int `json:"bytes_parsed" yaml:"bytes_parsed" mapstructure:"bytes_parsed"`

	// NumBytes corresponds to the JSON schema field "num_bytes".
	NumBytes int `json:"num_bytes" yaml:"num_bytes" mapstructure:"num_bytes"`

	// NumTargets corresponds to the JSON schema field "num_targets".
	NumTargets int `json:"num_targets" yaml:"num_targets" mapstructure:"num_targets"`

	// TargetsParsed corresponds to the JSON schema field "targets_parsed".
	TargetsParsed int `json:"targets_parsed" yaml:"targets_parsed" mapstructure:"targets_parsed"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreError) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["error_type"]; !ok || v == nil {
		return fmt.Errorf("field error_type in CoreError: required")
	}
	if v, ok := raw["location"]; !ok || v == nil {
		return fmt.Errorf("field location in CoreError: required")
	}
	if v, ok := raw["message"]; !ok || v == nil {
		return fmt.Errorf("field message in CoreError: required")
	}
	if v, ok := raw["severity"]; !ok || v == nil {
		return fmt.Errorf("field severity in CoreError: required")
	}
	type Plain CoreError
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreError(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ErrorSpan) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["end"]; !ok || v == nil {
		return fmt.Errorf("field end in ErrorSpan: required")
	}
	if v, ok := raw["file"]; !ok || v == nil {
		return fmt.Errorf("field file in ErrorSpan: required")
	}
	if v, ok := raw["start"]; !ok || v == nil {
		return fmt.Errorf("field start in ErrorSpan: required")
	}
	type Plain ErrorSpan
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ErrorSpan(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CiScanCompleteResponse) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["exit_code"]; !ok || v == nil {
		return fmt.Errorf("field exit_code in CiScanCompleteResponse: required")
	}
	if v, ok := raw["stats"]; !ok || v == nil {
		return fmt.Errorf("field stats in CiScanCompleteResponse: required")
	}
	type Plain CiScanCompleteResponse
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CiScanCompleteResponse(plain)
	return nil
}

type Version string

type RuleId string

// UnmarshalJSON implements json.Unmarshaler.
func (j *CoreOutput) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in CoreOutput: required")
	}
	if v, ok := raw["paths"]; !ok || v == nil {
		return fmt.Errorf("field paths in CoreOutput: required")
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in CoreOutput: required")
	}
	type Plain CoreOutput
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CoreOutput(plain)
	return nil
}

type CoreSeverity interface{}

type Datetime string

type Ecosystem interface{}

type EngineKind interface{}

type IncompatibleRule struct {
	// MaxVersion corresponds to the JSON schema field "max_version".
	MaxVersion *Version `json:"max_version,omitempty" yaml:"max_version,omitempty" mapstructure:"max_version,omitempty"`

	// MinVersion corresponds to the JSON schema field "min_version".
	MinVersion *Version `json:"min_version,omitempty" yaml:"min_version,omitempty" mapstructure:"min_version,omitempty"`

	// RuleId corresponds to the JSON schema field "rule_id".
	RuleId RuleId `json:"rule_id" yaml:"rule_id" mapstructure:"rule_id"`

	// ThisVersion corresponds to the JSON schema field "this_version".
	ThisVersion Version `json:"this_version" yaml:"this_version" mapstructure:"this_version"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IncompatibleRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["rule_id"]; !ok || v == nil {
		return fmt.Errorf("field rule_id in IncompatibleRule: required")
	}
	if v, ok := raw["this_version"]; !ok || v == nil {
		return fmt.Errorf("field this_version in IncompatibleRule: required")
	}
	type Plain IncompatibleRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = IncompatibleRule(plain)
	return nil
}

type MatchCallTrace interface{}

type MatchingOperation interface{}

type ProjectMetadata struct {
	// BaseSha corresponds to the JSON schema field "base_sha".
	BaseSha *string `json:"base_sha,omitempty" yaml:"base_sha,omitempty" mapstructure:"base_sha,omitempty"`

	// Branch corresponds to the JSON schema field "branch".
	Branch *string `json:"branch" yaml:"branch" mapstructure:"branch"`

	// CiJobUrl corresponds to the JSON schema field "ci_job_url".
	CiJobUrl *string `json:"ci_job_url" yaml:"ci_job_url" mapstructure:"ci_job_url"`

	// Commit corresponds to the JSON schema field "commit".
	Commit *string `json:"commit" yaml:"commit" mapstructure:"commit"`

	// CommitAuthorEmail corresponds to the JSON schema field "commit_author_email".
	CommitAuthorEmail *string `json:"commit_author_email" yaml:"commit_author_email" mapstructure:"commit_author_email"`

	// CommitAuthorImageUrl corresponds to the JSON schema field
	// "commit_author_image_url".
	CommitAuthorImageUrl *string `json:"commit_author_image_url" yaml:"commit_author_image_url" mapstructure:"commit_author_image_url"`

	// CommitAuthorName corresponds to the JSON schema field "commit_author_name".
	CommitAuthorName *string `json:"commit_author_name" yaml:"commit_author_name" mapstructure:"commit_author_name"`

	// CommitAuthorUsername corresponds to the JSON schema field
	// "commit_author_username".
	CommitAuthorUsername *string `json:"commit_author_username" yaml:"commit_author_username" mapstructure:"commit_author_username"`

	// CommitTimestamp corresponds to the JSON schema field "commit_timestamp".
	CommitTimestamp *string `json:"commit_timestamp,omitempty" yaml:"commit_timestamp,omitempty" mapstructure:"commit_timestamp,omitempty"`

	// CommitTitle corresponds to the JSON schema field "commit_title".
	CommitTitle *string `json:"commit_title" yaml:"commit_title" mapstructure:"commit_title"`

	// IsCodeScan corresponds to the JSON schema field "is_code_scan".
	IsCodeScan *bool `json:"is_code_scan,omitempty" yaml:"is_code_scan,omitempty" mapstructure:"is_code_scan,omitempty"`

	// IsFullScan corresponds to the JSON schema field "is_full_scan".
	IsFullScan bool `json:"is_full_scan" yaml:"is_full_scan" mapstructure:"is_full_scan"`

	// IsScaScan corresponds to the JSON schema field "is_sca_scan".
	IsScaScan *bool `json:"is_sca_scan,omitempty" yaml:"is_sca_scan,omitempty" mapstructure:"is_sca_scan,omitempty"`

	// IsSecretsScan corresponds to the JSON schema field "is_secrets_scan".
	IsSecretsScan *bool `json:"is_secrets_scan,omitempty" yaml:"is_secrets_scan,omitempty" mapstructure:"is_secrets_scan,omitempty"`

	// On corresponds to the JSON schema field "on".
	On string `json:"on" yaml:"on" mapstructure:"on"`

	// PullRequestAuthorImageUrl corresponds to the JSON schema field
	// "pull_request_author_image_url".
	PullRequestAuthorImageUrl *string `json:"pull_request_author_image_url" yaml:"pull_request_author_image_url" mapstructure:"pull_request_author_image_url"`

	// PullRequestAuthorUsername corresponds to the JSON schema field
	// "pull_request_author_username".
	PullRequestAuthorUsername *string `json:"pull_request_author_username" yaml:"pull_request_author_username" mapstructure:"pull_request_author_username"`

	// PullRequestId corresponds to the JSON schema field "pull_request_id".
	PullRequestId *string `json:"pull_request_id" yaml:"pull_request_id" mapstructure:"pull_request_id"`

	// PullRequestTitle corresponds to the JSON schema field "pull_request_title".
	PullRequestTitle *string `json:"pull_request_title" yaml:"pull_request_title" mapstructure:"pull_request_title"`

	// RepoUrl corresponds to the JSON schema field "repo_url".
	RepoUrl *string `json:"repo_url" yaml:"repo_url" mapstructure:"repo_url"`

	// Repository corresponds to the JSON schema field "repository".
	Repository string `json:"repository" yaml:"repository" mapstructure:"repository"`

	// ScanEnvironment corresponds to the JSON schema field "scan_environment".
	ScanEnvironment string `json:"scan_environment" yaml:"scan_environment" mapstructure:"scan_environment"`

	// SemgrepVersion corresponds to the JSON schema field "semgrep_version".
	SemgrepVersion Version `json:"semgrep_version" yaml:"semgrep_version" mapstructure:"semgrep_version"`

	// StartSha corresponds to the JSON schema field "start_sha".
	StartSha *string `json:"start_sha,omitempty" yaml:"start_sha,omitempty" mapstructure:"start_sha,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ProjectMetadata) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["branch"]; !ok || v == nil {
		return fmt.Errorf("field branch in ProjectMetadata: required")
	}
	if v, ok := raw["ci_job_url"]; !ok || v == nil {
		return fmt.Errorf("field ci_job_url in ProjectMetadata: required")
	}
	if v, ok := raw["commit"]; !ok || v == nil {
		return fmt.Errorf("field commit in ProjectMetadata: required")
	}
	if v, ok := raw["commit_author_email"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_email in ProjectMetadata: required")
	}
	if v, ok := raw["commit_author_image_url"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_image_url in ProjectMetadata: required")
	}
	if v, ok := raw["commit_author_name"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_name in ProjectMetadata: required")
	}
	if v, ok := raw["commit_author_username"]; !ok || v == nil {
		return fmt.Errorf("field commit_author_username in ProjectMetadata: required")
	}
	if v, ok := raw["commit_title"]; !ok || v == nil {
		return fmt.Errorf("field commit_title in ProjectMetadata: required")
	}
	if v, ok := raw["is_full_scan"]; !ok || v == nil {
		return fmt.Errorf("field is_full_scan in ProjectMetadata: required")
	}
	if v, ok := raw["on"]; !ok || v == nil {
		return fmt.Errorf("field on in ProjectMetadata: required")
	}
	if v, ok := raw["pull_request_author_image_url"]; !ok || v == nil {
		return fmt.Errorf("field pull_request_author_image_url in ProjectMetadata: required")
	}
	if v, ok := raw["pull_request_author_username"]; !ok || v == nil {
		return fmt.Errorf("field pull_request_author_username in ProjectMetadata: required")
	}
	if v, ok := raw["pull_request_id"]; !ok || v == nil {
		return fmt.Errorf("field pull_request_id in ProjectMetadata: required")
	}
	if v, ok := raw["pull_request_title"]; !ok || v == nil {
		return fmt.Errorf("field pull_request_title in ProjectMetadata: required")
	}
	if v, ok := raw["repo_url"]; !ok || v == nil {
		return fmt.Errorf("field repo_url in ProjectMetadata: required")
	}
	if v, ok := raw["repository"]; !ok || v == nil {
		return fmt.Errorf("field repository in ProjectMetadata: required")
	}
	if v, ok := raw["scan_environment"]; !ok || v == nil {
		return fmt.Errorf("field scan_environment in ProjectMetadata: required")
	}
	if v, ok := raw["semgrep_version"]; !ok || v == nil {
		return fmt.Errorf("field semgrep_version in ProjectMetadata: required")
	}
	type Plain ProjectMetadata
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ProjectMetadata(plain)
	return nil
}

type Meta struct {
	// Meta corresponds to the JSON schema field "meta".
	Meta ProjectMetadata `json:"meta" yaml:"meta" mapstructure:"meta"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Meta) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["meta"]; !ok || v == nil {
		return fmt.Errorf("field meta in Meta: required")
	}
	type Plain Meta
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Meta(plain)
	return nil
}

type Product interface{}

type RawJson interface{}

type ScaParserName interface{}

type Sha1 string

type SkipReason interface{}

type Transitivity interface{}

type Uri string

type ValidationState interface{}

type SemgrepOutputV1JsonschemaEngineRequested interface{}

// Translated by atdcat from 'semgrep_output_v1.atd'.
type SemgrepOutputV1Jsonschema struct {
	// EngineRequested corresponds to the JSON schema field "engine_requested".
	EngineRequested SemgrepOutputV1JsonschemaEngineRequested `json:"engine_requested,omitempty" yaml:"engine_requested,omitempty" mapstructure:"engine_requested,omitempty"`

	// Errors corresponds to the JSON schema field "errors".
	Errors []CliError `json:"errors" yaml:"errors" mapstructure:"errors"`

	// Explanations corresponds to the JSON schema field "explanations".
	Explanations []MatchingExplanation `json:"explanations,omitempty" yaml:"explanations,omitempty" mapstructure:"explanations,omitempty"`

	// Paths corresponds to the JSON schema field "paths".
	Paths ScannedAndSkipped `json:"paths" yaml:"paths" mapstructure:"paths"`

	// Results corresponds to the JSON schema field "results".
	Results []CliMatch `json:"results" yaml:"results" mapstructure:"results"`

	// RulesByEngine corresponds to the JSON schema field "rules_by_engine".
	RulesByEngine []RuleIdAndEngineKind `json:"rules_by_engine,omitempty" yaml:"rules_by_engine,omitempty" mapstructure:"rules_by_engine,omitempty"`

	// SkippedRules corresponds to the JSON schema field "skipped_rules".
	SkippedRules []SkippedRule `json:"skipped_rules,omitempty" yaml:"skipped_rules,omitempty" mapstructure:"skipped_rules,omitempty"`

	// Time corresponds to the JSON schema field "time".
	Time *Profile `json:"time,omitempty" yaml:"time,omitempty" mapstructure:"time,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *Version `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SemgrepOutputV1Jsonschema) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["errors"]; !ok || v == nil {
		return fmt.Errorf("field errors in SemgrepOutputV1Jsonschema: required")
	}
	if v, ok := raw["paths"]; !ok || v == nil {
		return fmt.Errorf("field paths in SemgrepOutputV1Jsonschema: required")
	}
	if v, ok := raw["results"]; !ok || v == nil {
		return fmt.Errorf("field results in SemgrepOutputV1Jsonschema: required")
	}
	type Plain SemgrepOutputV1Jsonschema
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = SemgrepOutputV1Jsonschema(plain)
	return nil
}
